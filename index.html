<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arbeitsproben</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Arbeitsproben</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgd3e6742">Numerische Berechnungen von Elektro-magnetischen Phänomenen</a></li>
<li><a href="#org930c090">Die harmonische Störung des dielektrischen Feldes</a>
<ul>
<li><a href="#orgc08526c">Codebeispiel: Die Sinusfunktion eine Lösung des freien Feldes</a></li>
</ul>
</li>
<li><a href="#org52fd37e">Lösung der Wellengleichung in endlichen Geometrien</a>
<ul>
<li><a href="#org7151b6f">Potential in einem Zylinder</a></li>
</ul>
</li>
<li><a href="#org65b3a82">Bestimmte Harmonische: Flüstergaleriemoden</a>
<ul>
<li><a href="#orgbd8e251">Allgemeine Funktion der 3D-Wellengleichung</a></li>
<li><a href="#org67b1214">Die Azimutale Funktion</a>
<ul>
<li><a href="#orge91d041">Codebeispiel: Azimutale Funktion</a></li>
</ul>
</li>
<li><a href="#org6a89902">Funktion der Z-Koordinate bzw. der Höhe</a>
<ul>
<li><a href="#org7ccef00">Codebeispiel für die vertikale Richtung</a></li>
</ul>
</li>
<li><a href="#org200c513">Die Radiale Funktion</a>
<ul>
<li><a href="#org0a79846">Codebeispiel der Besselfunktionen</a></li>
<li><a href="#orge8705ed">Codebeispiel der radialen Funktion innerhalb des Resonators</a></li>
<li><a href="#org93b927e">Codebeispiel der radialen Funktion außerhalb des Resonators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9264527">Numerische Approximation</a>
<ul>
<li><a href="#orgb7ceba7">Codebeispiel:</a></li>
</ul>
</li>
<li><a href="#orgd8eae65"><span class="todo TODO">TODO</span> Besser erklären: Konzeptzeichnung bzw. Beispielcode. <span class="timestamp-wrapper"><span class="timestamp">&lt;2023-03-07 Tue&gt;</span></span>shoshin</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgd3e6742" class="outline-2">
<h2 id="orgd3e6742">Numerische Berechnungen von Elektro-magnetischen Phänomenen</h2>
<div class="outline-text-2" id="text-orgd3e6742">
<p>
Auf dieser Site stelle ich vor, wie ein physikalisches Phänomen - nämlich die Lichtausbreitung in dielektrischen, runden Resonatoren
und wie sie mathematisch beschrieben werden kann. Dabei kommen Theorie und Code-Beispiele zum Einsatz. Im Resultat werden Lösungen von
Differentialgleichungen mit einem numerischen Verfahren vorgestellt. <b>Hinweis:</b> momentan ist dieser Code noch in einem anderen <a href="https://github.com/shosh1n/EMCuda">Repository</a>.
Das Phänomen, welches hier maßgeblich beschrieben werden soll, ist das Phänomen der Flüstergaleriemoden.
</p>
</div>
</div>

<div id="outline-container-org930c090" class="outline-2">
<h2 id="org930c090">Die harmonische Störung des dielektrischen Feldes</h2>
<div class="outline-text-2" id="text-org930c090">
<p>
Zunächst wird im Zuge auf die Ausbreitung des Lichts festgelegt, dass nur harmonische Veränderungen des Feldes betrachtet werden. D.h. dass periodische Veränderungen
des Feldes durch Sinus- und Cosinusfunktionen beschrieben werden können. Mathematisch generell &ldquo;gesprochen&rdquo; kommen die periodischen Schwinungen aus der Wellengleichung:
</p>

\begin{equation}
     \Delta\mathbf{E} - \frac{1}{c_{m}^{2}}\frac{\partial^{2}E}{\partial t^{2}} = 0
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(\Delta\)</td>
<td class="org-left">Laplace-Operator</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{E}\)</td>
<td class="org-left">Elektrische Feld</td>
</tr>

<tr>
<td class="org-left">\(c_{m}\)</td>
<td class="org-left">Lichtgeschwindigkeit im Medium</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{k}\)</td>
<td class="org-left">Wellenvektor</td>
</tr>

<tr>
<td class="org-left">\(j\)</td>
<td class="org-left">Imaginäre Einheit</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{r}\)</td>
<td class="org-left">Ortsvektor</td>
</tr>

<tr>
<td class="org-left">\(\omega\)</td>
<td class="org-left">Kreisfrequenz: \hspace{.5mm} \(2\pi f\)</td>
</tr>

<tr>
<td class="org-left">\(t\)</td>
<td class="org-left">Zeiteinheit</td>
</tr>
</tbody>
</table>

<p>
Allgemein kann das elektrische <b>Freie Feld</b> über folgenden algebraischen Ausdruck zusammengefasst werden:
</p>
\begin{equation}
    \mathbf{E} (\mathbf{r},t) = E(\mathbf{z},t)
    = E_{0}\exp{j\mathbf{k}\cdot\mathbf{r}-j\omega t}
\end{equation}
</div>
<div id="outline-container-orgc08526c" class="outline-3">
<h3 id="orgc08526c">Codebeispiel: Die Sinusfunktion eine Lösung des freien Feldes</h3>
<div class="outline-text-3" id="text-orgc08526c">
<p>
Eine einfache Lösung der Wellengleichung ist die Sinusfunktion. Durch diese können periodische Schwankungen am Ort oder in der Zeit beschrieben werden.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt

<span class="org-variable-name">x</span>  = np.linspace(0, 20, 100)

<span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1):
    <span class="org-variable-name">y</span> = np.sin(x);
    plt.plot(x,y,label=r<span class="org-string">'$Sin(x)$'</span>)

plt.axhline(0,color=<span class="org-string">'green'</span>, label=<span class="org-string">'_nolegend_'</span>)
plt.grid()
plt.legend()
plt.xlabel(<span class="org-string">'$x$'</span>)
plt.ylabel(<span class="org-string">'${Sin}(x)$'</span>)
plt.title(r<span class="org-string">'Die Harmonische Schwingung - Sinusfunktion $Sin(x)$'</span>)
plt.savefig(<span class="org-string">'img/matplot-fig.png'</span>)
<span class="org-keyword">return</span> <span class="org-string">'img/matplot-fig.png'</span>

</pre>
</div>




<div id="org260798c" class="figure">
<p><img src="./img/matplot-fig.png" alt="1DSinus" title="Sinus" align="center" />
</p>
<p><span class="figure-number">Figure 1: </span>Eine 1D-Sinusfunktion</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org52fd37e" class="outline-2">
<h2 id="org52fd37e">Lösung der Wellengleichung in endlichen Geometrien</h2>
<div class="outline-text-2" id="text-org52fd37e">
<p>
Zu Beginn des Textes wurde die Wellengleichung ohne große Einschränkungen gelöst. In realen Systemen ist so eine Lösung ungenau. In einem unendlich großen
störungsfreien Raum, stellt die 1D-Sinusfunktion eine gültige Lösung dar.
</p>

<p>
Für endliche Räume müssen weitere Berücksichtigungen getroffen werden. Eine einfache Geometrie für Resonatoren ist ein Zylinder.
Ein Zylinder hat schon 3-Raumkoordinaten. Um die periodische Störung zu lösen müssen entsprechend dieser Raumkoordinaten Funktionen gefunden werden, die den
Zylinderraum vollständig beschreiben können.
</p>
</div>

<div id="outline-container-org7151b6f" class="outline-3">
<h3 id="org7151b6f">Potential in einem Zylinder</h3>
<div class="outline-text-3" id="text-org7151b6f">
<p>
Da eine Störung eine Veränderung herbeiführt, wird ein Differentialoperator auf eine Größe \(\psi\) angewandt. Dieser beschreibende Veränderungsoperator berücksichtigt
die 3-Raumrichtungen und hat folgende Funktionsvorschrift:
</p>

\begin{equation}\label{eqn:ZylinderWelle}
    -\frac{1}{2}\Big[ \frac{1}{\rho} \frac{\partial}{\partial \rho} \Big( \rho \frac{\partial}{\partial \rho} \Big) + \frac{1}{\rho^{2}}\frac{\partial^{2}}{\partial \varphi^{2}} + \frac{\partial^{2}}{\partial z^{2}} \Big] \psi = L\psi
\end{equation}
</div>
</div>
</div>



<div id="outline-container-org65b3a82" class="outline-2">
<h2 id="org65b3a82">Bestimmte Harmonische: Flüstergaleriemoden</h2>
<div class="outline-text-2" id="text-org65b3a82">
<p>
Flüstergaleriemoden sind auch bestimmte Harmonische Störungen im Raum. Sie sind an der Seitenwand eines Resonators zu verorten. Ihre Entdeckung beruht auf einer akustischen Beobachtung von Schallwellen,
die an der Wand einer Kuppel reflektiert werden, d.h. die Schallausbreitung findet über Reflektion der Schallwellen an der Kuppelwand statt.
Ist die Wellenlänge sind bestimmte Größen des System bekannt, dann Eine Wellenzahl - oder auch ein quantisierter Zustand der Harmonischen Störung
bestimmt werden.
</p>
</div>

<div id="outline-container-orgbd8e251" class="outline-3">
<h3 id="orgbd8e251">Allgemeine Funktion der 3D-Wellengleichung</h3>
<div class="outline-text-3" id="text-orgbd8e251">
<p>
Im Besten Fall kann eine Wellenfunktion gefunden werden, die sich aus 3 einzelnen Funktionen entsprechend der Raumkoordinaten zusammensetzt.
Ohne große Überlegung kann die Funktion folgendermaßen geschrieben werden:
</p>

\begin{equation}\label{eqn:ZylinderPotential}
    \psi = R(\rho)Z(z)\Phi(\varphi).
\end{equation}

<p>
In den folgenden Abschnitte werden diese Funktionen einzeln betrachtet.
</p>
</div>
</div>

<div id="outline-container-org67b1214" class="outline-3">
<h3 id="org67b1214">Die Azimutale Funktion</h3>
<div class="outline-text-3" id="text-org67b1214">
<p>
Als erstes lässt sich relativ einfach die azimutale Funktion bestimmen. Die Azimutale Funktion umläuft den Zylinder.
Folgendes Codebeispiel veranschautlicht diese.
</p>
</div>

<div id="outline-container-orge91d041" class="outline-4">
<h4 id="orge91d041">Codebeispiel: Azimutale Funktion</h4>
<div class="outline-text-4" id="text-orge91d041">
<div class="org-src-container">
<pre class="src src-python">

<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d
<span class="org-keyword">import</span> mpl_toolkits.mplot3d.art3d <span class="org-keyword">as</span> art3d
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> Circle
<span class="org-keyword">from</span> matplotlib <span class="org-keyword">import</span> pyplot <span class="org-keyword">as</span> plt

<span class="org-comment-delimiter">#</span><span class="org-comment">Define a class for the coordinate-system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>._verts3d = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        <span class="org-variable-name">xs3d</span>, <span class="org-variable-name">ys3d</span>, <span class="org-variable-name">zs3d</span> = <span class="org-keyword">self</span>._verts3d
        <span class="org-variable-name">xs</span>, <span class="org-variable-name">ys</span>, <span class="org-variable-name">zs</span> = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">This Function will draw a cylinder</span>
<span class="org-keyword">def</span> <span class="org-function-name">plot_3D_cylinder</span>(radius, height, elevation=0, resolution=100, color=<span class="org-string">'b'</span>, x_center = 0, y_center = 0):

    <span class="org-comment-delimiter">#</span><span class="org-comment">init where to draw the projections</span>
    <span class="org-variable-name">fig</span>=plt.figure(figsize=(5,5))
    <span class="org-variable-name">ax</span> = Axes3D(fig, azim=45, elev=21)

    <span class="org-comment-delimiter">#</span><span class="org-comment">take values from the function input</span>
    <span class="org-variable-name">x</span> = np.linspace(x_center-radius, x_center+radius, resolution)
    <span class="org-variable-name">z</span> = np.linspace(elevation, elevation+height, resolution)
    <span class="org-variable-name">X</span>, <span class="org-variable-name">Z</span> = np.meshgrid(x, z)

    <span class="org-variable-name">theta</span> = np.linspace(-1 * np.pi, 1 * np.pi, 1000)

    <span class="org-comment-delimiter">#</span><span class="org-comment">coordinate conversion cartesain x_,y_,z_ in cylindrical</span>
    <span class="org-variable-name">R</span> = 1
    <span class="org-variable-name">x_</span> = radius * np.cos(theta)+x_center
    <span class="org-variable-name">y_</span> = radius *np.sin(theta)+y_center
    <span class="org-variable-name">z_</span> = np.sin(18*theta)
    <span class="org-variable-name">Y</span> = np.sqrt(radius**2 - (X - x_center)**2) + y_center <span class="org-comment-delimiter"># </span><span class="org-comment">Pythagorean theorem</span>


    <span class="org-comment-delimiter">#</span><span class="org-comment">Color the cylinder surface-patches</span>
    ax.plot_surface(X, Y, Z,alpha=0.3, linewidth=0, color=<span class="org-string">'deepskyblue'</span>)
    ax.plot_surface(X, (2*y_center-Y), Z,alpha=0.2, linewidth=0, color=<span class="org-string">'lightskyblue'</span>)
    <span class="org-variable-name">floor</span> = Circle((x_center, y_center), radius, color=<span class="org-string">'deepskyblue'</span>,alpha=0.3)
    ax.add_patch(floor)
    art3d.pathpatch_2d_to_3d(floor, z=elevation, zdir=<span class="org-string">"z"</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Color the circle-surfaces</span>
    <span class="org-variable-name">ceiling</span> = Circle((x_center, y_center), radius, color=<span class="org-string">'deepskyblue'</span>,alpha=0.5)
    ax.add_patch(ceiling)
    art3d.pathpatch_2d_to_3d(ceiling, z=elevation+height, zdir=<span class="org-string">"z"</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Plot the encircling function</span>
    ax.plot(x_, y_, z_, color = <span class="org-string">'fuchsia'</span>)

    <span class="org-variable-name">arrow_prop_dict</span> = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add an arrow that outlines the function's path</span>
    <span class="org-variable-name">a</span> = Arrow3D([0, 79], [0, 15], [0, 2.8], **arrow_prop_dict, color=<span class="org-string">'darkorchid'</span>, linestyle=<span class="org-string">"dashed"</span>,linewidth=3.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a red orthogonal arrow in the \rho respectively y-direction</span>
    <span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 75], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the y-cartesain coordinate</span>
    <span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 95], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the x-cartesain coordinate</span>
    <span class="org-variable-name">a</span> = Arrow3D([0, 95], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the z-direction</span>
    <span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 0], [0, 6.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a blue arrow indicating the z-direction</span>
    <span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 0], [0, 6], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">add letters for orientation o-origin, \rho etc. ...</span>
    ax.text(3, 0.0, -.35, r<span class="org-string">'$o$'</span>)
    ax.text(0, 75, 0, r<span class="org-string">'$\rho$'</span>)
    ax.text(60, 60, 0, r<span class="org-string">'$\varphi$'</span>)
    ax.text(0, -2, 7, r<span class="org-string">'$z$'</span>)
    ax.text(107, 15, 3.4, r<span class="org-string">'$\psi(\rho,z,\varphi)$'</span>)
    ax.text(100, 0, 0, r<span class="org-string">'$x$'</span>)
    ax.text(0, 98, 0, r<span class="org-string">'$y$'</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Now draw the \varphi-axis *hint: it's angle dependent 'cause it's a cylinder</span>
    <span class="org-variable-name">thetaAng</span> = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>
    <span class="org-variable-name">rAng</span> =  50.0 <span class="org-comment-delimiter">#</span><span class="org-comment">circle radius</span>
    <span class="org-variable-name">x1</span> = rAng * np.cos(thetaAng) + 0
    <span class="org-variable-name">x2</span> = rAng * np.sin(thetaAng) + 0

    <span class="org-comment-delimiter">#</span><span class="org-comment">Plot this axis as a function and make it green</span>
    ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)

    <span class="org-comment-delimiter">#</span><span class="org-comment">name the axis</span>
    ax.set_xlabel(<span class="org-string">'x-Achse'</span>, fontsize=16)
    ax.set_ylabel(<span class="org-string">'y-Achse'</span>, fontsize=16)
    ax.set_zlabel(<span class="org-string">'z-Achse'</span>, fontsize=16)


    <span class="org-comment-delimiter">#</span><span class="org-comment">set a limit on the z-axis/**sorry it's messy &lt;2023-03-02 Thu&gt; shoshin</span>
    ax.set_zlim(-4,4)

    <span class="org-comment-delimiter">#</span><span class="org-comment">clean the canvas no grid whatsoever or other oob stuff</span>
    <span class="org-variable-name">ax.xaxis.pane.fill</span> = <span class="org-constant">False</span>
    <span class="org-variable-name">ax.yaxis.pane.fill</span> = <span class="org-constant">False</span>
    <span class="org-variable-name">ax.zaxis.pane.fill</span> = <span class="org-constant">False</span>
    ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
    ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
    ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)

    ax.grid(<span class="org-constant">False</span>)
    <span class="org-variable-name">font</span> = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
    plt.rc(<span class="org-string">'font'</span>, **font)
    <span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Zylindrische Kavit&#228;t", fontsize=25)</span>
    plt.axis(<span class="org-string">'off'</span>)
    <span class="org-comment-delimiter">#</span><span class="org-comment">fig.savefig('ZylinderSystem.png', dpi=320)</span>
    plt.show()

<span class="org-comment-delimiter">#</span><span class="org-comment">create a figure for plotting</span>
<span class="org-variable-name">fig</span> = plt.figure()

<span class="org-comment-delimiter">#</span><span class="org-comment">create a 3d ax-element</span>
<span class="org-variable-name">ax</span> = fig.add_subplot(111, projection=<span class="org-string">'3d'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">adjust view on the art-piece</span>
ax.view_init(azim=-90, elev=90)
ax.set_axis_off()
plt.show()


<span class="org-comment-delimiter"># </span><span class="org-comment">Write parameters to be passed to above cylinder function</span>
<span class="org-variable-name">radius</span> = 50
<span class="org-variable-name">height</span> = 2
<span class="org-variable-name">elevation</span> = -1
<span class="org-variable-name">resolution</span> = 100
<span class="org-variable-name">color</span> = <span class="org-string">'lightskyblue'</span>
<span class="org-variable-name">x_center</span> = 0
<span class="org-variable-name">y_center</span> = 0

<span class="org-comment-delimiter"># </span><span class="org-comment">pass the parameter</span>
plot_3D_cylinder(radius, height, elevation=elevation, resolution=resolution, color=color, x_center=x_center, y_center=y_center)

<span class="org-comment-delimiter">#</span><span class="org-comment">save the figure</span>
plt.savefig(<span class="org-string">'img/matplot-azimuthal.png'</span>)
<span class="org-comment-delimiter">#</span><span class="org-comment">return 'img/matplot-azimuthal.png'</span>


</pre>
</div>

<p>
<a href="None">None</a>
</p>


<div id="org713449c" class="figure">
<p><img src="./img/matplot-azimuthal.png" alt="matplot-azimuthal.png" title="AzimutaleFunktion" align="center" />
</p>
<p><span class="figure-number">Figure 2: </span>Die azimutale Funktion beschreibt die Umlaufrichtung</p>
</div>

\begin{equation}\label{eqn:azimuthal-Zahl}
  m = \frac{2\pi r n_{m}}{\lambda_{0}}
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(m\)</td>
<td class="org-left">Azimutale Quantenzahl</td>
</tr>

<tr>
<td class="org-left">\(r\)</td>
<td class="org-left">Radius</td>
</tr>

<tr>
<td class="org-left">\(n_{m}\)</td>
<td class="org-left">Brechungsindex</td>
</tr>
</tbody>
</table>

<p>
Der mathematische Ausdruck ist im Vergleich zum oberen Codebeispiel ziemlich unspektakulär:
</p>
\begin{equation}
     \Phi(\varphi) = e^{(jm \varphi)}
\end{equation}
</div>
</div>
</div>

<div id="outline-container-org6a89902" class="outline-3">
<h3 id="org6a89902">Funktion der Z-Koordinate bzw. der Höhe</h3>
<div class="outline-text-3" id="text-org6a89902">
<p>
Für die Funktion \(Z(z)\) ergeben sich unterschiedliche Funktionen. Symmetrische, auch als unsymmetrische  Funktionen.
Das Liegt daran, dass sowohl Cosinus als auch Sinus zulässig sind.
</p>


\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
       A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big),   & \text{für } z < - \bigg(\frac{h}{2}\bigg) .\\
       B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big), & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
       A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg)
        \end{array}\right.
\end{equation}

<p>
und unsymmetrischen Lösungen:
</p>

\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
        A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z \Big),   & \text{für } z < -\bigg(\frac{h}{2}\bigg) .\\
        B sin\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big) , & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
        - A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg).
        \end{array}\right.
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="Wellenzahlen" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(k_{eff}\)</td>
<td class="org-left">effektive Wellenzahl einer Mode</td>
</tr>

<tr>
<td class="org-left">\(k_{i}\)</td>
<td class="org-left">Wellenzahl im Festkörper</td>
</tr>

<tr>
<td class="org-left">\(k_{0}\)</td>
<td class="org-left">Wellenzahl im Vakuum</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">Höhe eines Resonators</td>
</tr>
</tbody>
</table>

<p>
Die Höhe \(h\) gibt die Randbedingung für die Gültigkeit der Sinus/Cosinus Funktion für die $Z$-Koordinate wieder. Jenseits einer gegebenen Höhe sind andere Funktionen definiert, die mit zunehmendem/abnehmenden \(z\) exponential abfallen und gegen \(0\) gehen.
</p>
</div>

<div id="outline-container-org7ccef00" class="outline-4">
<h4 id="org7ccef00">Codebeispiel für die vertikale Richtung</h4>
</div>
</div>

<div id="outline-container-org200c513" class="outline-3">
<h3 id="org200c513">Die Radiale Funktion</h3>
<div class="outline-text-3" id="text-org200c513">
<p>
Für die radiale Funktion \(R(\rho)\) ergibt sich durch die Separation der Variablen Bessels-Differentialgleichung.
</p>

\begin{equation}\label{eqn:PreBessel}
    \rho^{2}\Big( \frac{d^{2}R}{d \rho^{2}}\Big) + (\rho^{2}k^{2}-m^{2})R = 0
\end{equation}

<p>
Durch die Substitution \(\mathbf{k \rho = x}\) ist der Ausdruck aus Gleichung als die allgemeine Form darstellbar.
</p>

\begin{equation}
    x^{2}\frac{d^{2}R}{dx^{2}}+\frac{dR}{dx}+(x^{2}-m^{2})R = 0
\end{equation}

<p>
Diese Differentialgleichung kann durch Besselfunktionen und Hankelfunktionen erster Gattung gelöst werden. Das Innere des Resonators wird dabei durch Besselfunktionen beschrieben.
</p>
\begin{equation}
   R(\rho) = J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big), \hspace{0.5cm} \rho < r
\end{equation}
</div>


<div id="outline-container-org0a79846" class="outline-4">
<h4 id="org0a79846">Codebeispiel der Besselfunktionen</h4>
<div class="outline-text-4" id="text-org0a79846">
<p>
Im Folgenden wird in Python ein Codebeispiel gezeigt, in welchem das Innere eines Resonators dargestellt wird. Es veranschaulicht eine radiale Veränderung des Elektromagnetischen Feldes.
</p>
</div>
</div>

<div id="outline-container-orge8705ed" class="outline-4">
<h4 id="orge8705ed">Codebeispiel der radialen Funktion innerhalb des Resonators</h4>
<div class="outline-text-4" id="text-orge8705ed">
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib
<span class="org-keyword">from</span> scipy.special <span class="org-keyword">import</span> hankel1e, y1_zeros
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d

<span class="org-comment-delimiter">#</span><span class="org-comment">needed for 3D-coordinate system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>._verts3d = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        <span class="org-variable-name">xs3d</span>, <span class="org-variable-name">ys3d</span>, <span class="org-variable-name">zs3d</span> = <span class="org-keyword">self</span>._verts3d
        <span class="org-variable-name">xs</span>, <span class="org-variable-name">ys</span>, <span class="org-variable-name">zs</span> = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">using circular coordinates again! range of theta-axis is needed</span>
<span class="org-variable-name">thetaAng</span> = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">assume the edge of the resonator to be rAng = 50</span>
<span class="org-variable-name">rAng</span> =  50.0
<span class="org-variable-name">x1</span> = rAng * np.cos(thetaAng) + 0
<span class="org-variable-name">x2</span> = rAng * np.sin(thetaAng) + 0

<span class="org-comment-delimiter">#</span><span class="org-comment">prepare the canvas and axis for the function</span>
<span class="org-variable-name">fig</span>=plt.figure(figsize=(5,5))
<span class="org-variable-name">ax</span> = Axes3D(fig, azim=45, elev=21)

<span class="org-comment-delimiter">#</span><span class="org-comment">create coordinate arrows for cylindrical and cartesian directions</span>
<span class="org-variable-name">arrow_prop_dict</span> = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)


<span class="org-comment-delimiter">#</span><span class="org-comment">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span class="org-string">'$o$'</span>)
ax.text(0, 55, 0, r<span class="org-string">'$\rho$'</span>)
ax.text(45, 45, 0, r<span class="org-string">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span class="org-string">'$z$'</span>)
ax.text(75, 0, 0, r<span class="org-string">'$x$'</span>)
ax.text(0, 70, 0, r<span class="org-string">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span class="org-string">'$R(\rho)$'</span>)


<span class="org-comment-delimiter">#</span><span class="org-comment">create the bessel-function</span>
<span class="org-keyword">def</span> <span class="org-function-name">drumhead_height</span>(n, k, distance, angle, t):

   <span class="org-variable-name">kth_zero</span> = sp.jn_zeros(n, k)[-1]

   <span class="org-keyword">return</span> np.cos(t) * np.cos(n*angle) * sp.jn(n, distance*kth_zero)

<span class="org-comment-delimiter">#</span><span class="org-comment">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
<span class="org-variable-name">theta</span> = np.r_[0:2*np.pi:50j]
<span class="org-variable-name">radius</span> = np.r_[0:50:50j]

<span class="org-comment-delimiter">#</span><span class="org-comment">transform cartesian coordinates into cylindrical ones</span>
<span class="org-variable-name">x</span> = np.array([r * np.cos(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
<span class="org-variable-name">y</span> = np.array([r * np.sin(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
<span class="org-variable-name">z</span> = np.array([drumhead_height(0,2, r, theta,1) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])


<span class="org-comment-delimiter">#</span><span class="org-comment">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span class="org-string">'jet'</span>,alpha=0.5)

<span class="org-comment-delimiter">#</span><span class="org-comment">set axis names and labels</span>
ax.set_xlabel(<span class="org-string">'x'</span>)
ax.set_ylabel(<span class="org-string">'y'</span>)
ax.set_zlabel(<span class="org-string">'z'</span>)

ax.set_xlabel(<span class="org-string">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span class="org-comment-delimiter">#</span><span class="org-comment">strip the figure of unnecessary stuff</span>
<span class="org-variable-name">ax.xaxis.pane.fill</span> = <span class="org-constant">False</span>
<span class="org-variable-name">ax.yaxis.pane.fill</span> = <span class="org-constant">False</span>
<span class="org-variable-name">ax.zaxis.pane.fill</span> = <span class="org-constant">False</span>
ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
<span class="org-variable-name">font</span> = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
plt.rc(<span class="org-string">'font'</span>, **font)
<span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span class="org-string">'off'</span>)
fig.tight_layout(pad=1.0)
<span class="org-comment-delimiter">#</span><span class="org-comment">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span class="org-string">'./img/BRadialeFunktion.png'</span>)
plt.show()



</pre>
</div>


<div id="org8f36cc8" class="figure">
<p><img src="./img/BRadialeFunktion.png" alt="BRadialeFunktion.png" title="Bessel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 3: </span>Die Besselfunktion beschreibt die radiale Veränderung der Wellenfunktion</p>
</div>
</div>
</div>


<div id="outline-container-org93b927e" class="outline-4">
<h4 id="org93b927e">Codebeispiel der radialen Funktion außerhalb des Resonators</h4>
<div class="outline-text-4" id="text-org93b927e">
<p>
Außerhalb der endlichen Geometrie des Resonator fallen die Ausprägungen des elektromagntischen Feldes stark ab. Durch Hankelfunktionen wird diesem Umstand mathematisch
Rechung getragen.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib
<span class="org-keyword">from</span> scipy.special <span class="org-keyword">import</span> hankel1e, y1_zeros
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d

<span class="org-comment-delimiter">#</span><span class="org-comment">needed for 3D-coordinate system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>._verts3d = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        <span class="org-variable-name">xs3d</span>, <span class="org-variable-name">ys3d</span>, <span class="org-variable-name">zs3d</span> = <span class="org-keyword">self</span>._verts3d
        <span class="org-variable-name">xs</span>, <span class="org-variable-name">ys</span>, <span class="org-variable-name">zs</span> = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">using circular coordinates again! range of theta-axis is needed</span>
<span class="org-variable-name">thetaAng</span> = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">assume the edge of the resonator to be rAng = 50</span>
<span class="org-variable-name">rAng</span> =  50.0
<span class="org-variable-name">x1</span> = rAng * np.cos(thetaAng) + 0
<span class="org-variable-name">x2</span> = rAng * np.sin(thetaAng) + 0

<span class="org-comment-delimiter">#</span><span class="org-comment">prepare the canvas and axis for the function</span>
<span class="org-variable-name">fig</span>=plt.figure(figsize=(5,5))
<span class="org-variable-name">ax</span> = Axes3D(fig, azim=45, elev=21)

<span class="org-comment-delimiter">#</span><span class="org-comment">create coordinate arrows for cylindrical and cartesian directions</span>
<span class="org-variable-name">arrow_prop_dict</span> = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)

<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
<span class="org-variable-name">a</span> = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)

<span class="org-comment-delimiter">#</span><span class="org-comment">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span class="org-string">'$o$'</span>)
ax.text(0, 55, 0, r<span class="org-string">'$\rho$'</span>)
ax.text(45, 45, 0, r<span class="org-string">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span class="org-string">'$z$'</span>)
ax.text(75, 0, 0, r<span class="org-string">'$x$'</span>)
ax.text(0, 70, 0, r<span class="org-string">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span class="org-string">'$R(\rho)$'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the hankel-function</span>
<span class="org-keyword">def</span> <span class="org-function-name">drumhead_height</span>(n, k, distance, angle, t):

   <span class="org-variable-name">kth_zero</span> = sp.jn_zeros(n, k)[-1]

   <span class="org-keyword">return</span> np.cos(t) * np.cos(n*angle) * sp.hankel1e(n, distance*kth_zero)

<span class="org-comment-delimiter">#</span><span class="org-comment">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
<span class="org-variable-name">theta</span> = np.r_[0:2*np.pi:50j]
<span class="org-variable-name">radius</span> = np.r_[55:75:50j]

<span class="org-comment-delimiter">#</span><span class="org-comment">transform cartesian coordinates into cylindrical ones</span>
<span class="org-variable-name">x</span> = np.array([r * np.cos(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
<span class="org-variable-name">y</span> = np.array([r * np.sin(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
<span class="org-variable-name">z</span> = np.array([drumhead_height(0,2, r, theta,1) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])

<span class="org-comment-delimiter">#</span><span class="org-comment">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span class="org-string">'jet'</span>,alpha=0.5)

<span class="org-comment-delimiter">#</span><span class="org-comment">set axis names and labels</span>
ax.set_xlabel(<span class="org-string">'x'</span>)
ax.set_ylabel(<span class="org-string">'y'</span>)
ax.set_zlabel(<span class="org-string">'z'</span>)

ax.set_xlabel(<span class="org-string">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span class="org-comment-delimiter">#</span><span class="org-comment">strip the figure of unnecessary stuff</span>
<span class="org-variable-name">ax.xaxis.pane.fill</span> = <span class="org-constant">False</span>
<span class="org-variable-name">ax.yaxis.pane.fill</span> = <span class="org-constant">False</span>
<span class="org-variable-name">ax.zaxis.pane.fill</span> = <span class="org-constant">False</span>
ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
<span class="org-variable-name">font</span> = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
plt.rc(<span class="org-string">'font'</span>, **font)
<span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span class="org-string">'off'</span>)
fig.tight_layout(pad=1.0)
<span class="org-comment-delimiter">#</span><span class="org-comment">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span class="org-string">'./img/HRadialeFunktion.png'</span>)
plt.show()


</pre>
</div>


<div id="org67f68f5" class="figure">
<p><img src="./img/HRadialeFunktion.png" alt="HRadialeFunktion.png" title="Hankel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 4: </span>Die Hankelfunktion beschreibt mathematisch den Abfall jenseits der Kavität</p>
</div>

<p>
Zu einer Funktion mit dem Index \(m\) können mehrere Nullstellen gefunden werden, deren Lage aus Tabellen bekannt ist&#x2026; Mit einem gewählten Radius \(r\) und einer Wellenzahl \(k\) können die Nullstellen für ein System bestimmt werden.
</p>

<p>
Mit den drei Quantenzahlen kann eine Eigenmode in einem Zylinder bestimmt werden. Für die Moden im Inneren des Zylinders ist die Funktion der symmetrischen Lösung gegeben durch:
</p>

\begin{equation}
        \mathbf{E(r)}_{q,l,m} =  J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big) B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big)\exp^{jm\varphi}
\end{equation}

<p>
In den hier vorgestellten Verhältnissen ist \(k_{eff}\) nicht bekannt. Aus der Bedingung, dass das magnetische Feld \(B(r) = -\frac{j}{\omega} \nabla\times E(r)\) an dem Übergang  \(\rho = r\) kontinuierlich ist, ergibt sich das Verhältnis, dass die radiale innere Lösung an diesem Punkt gleich der radialen äußeren Lösung sein muss.
</p>

\begin{equation}\label{eqn:effektiveWellenzahl}
    k_{eff}\frac{[J_{m}(k_{eff}\cdot r)]'}{J_{m}(k_{eff}\cdot r)}   = k_{0} \frac{[H^{1}_{m}(k_{0}\cdot r)]'}{H^{1}_{m}(k_{0}\cdot r)}
\end{equation}

<p>
Die Änderung der Funktion \([J_{m}(k_{eff}\cdot r)]'\) bzw. \([H^{1}_{m}(k_{0}\cdot r)]'\)  kann durch eine Finite-Elementen-Analyse numerisch genähert und gelöst werden. Dadurch kann die effektive Wellenzahl einer Mode gefunden werden.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org9264527" class="outline-2">
<h2 id="org9264527">Numerische Approximation</h2>
<div class="outline-text-2" id="text-org9264527">
<p>
Lösungen der Maxwellgleichungen können numerisch approximiert werden. Dabei werden zu untersuchende Strukturen auf einem Rechengitter projiziert. Ein einfaches Rechengitter lässt sich über folgenden Code in C realisieren
</p>
</div>
<div id="outline-container-orgb7ceba7" class="outline-3">
<h3 id="orgb7ceba7">Codebeispiel:</h3>
<div class="outline-text-3" id="text-orgb7ceba7">
<p>
Ich habe den Code in folgendes Repository <a href="https://github.com/shosh1n/EMCuda">EM-Cuda</a> verlagert: Er beinhaltet momentan verschiedene Matrixtransformationen, die Parallel auf einer Grafikkarte ausgeführt werden können. Im Sinne des Clean Code Prinzips muss dieser noch refaktorisiert werden.
</p>

<p>
Druch die Programmierung mit CUDA können viele Berechnungsschritte parallelisiert werden, d.h. zeitlich verkürzt, da diese nicht hintereinander gereiht werden müssen. Mann kann sich das so vorstellen,
als würde man Brot schneiden. Statt eine Scheibe Brot pro einer Zeiteinheit werden durch Paralleliesierung alle Scheiben des Brotes pro einer Zeiteinheit geschnitten. Das muss natürlich besonders programmiert werden.
</p>

<p>
Ein weiter Vorzug von CUDA ist, dass es auf der Programmiersprache C beruht und mit C++ kompatible ist, bzw. Programmiertechniken benutzt, die auch in C++ üblich sind. <a href="https://thrust.github.io/">Thrust</a> ist eine Programmierbibliothek,
die elegante Programmiermuster erlaubt. So sind z.B. über die <a href="https://de.wikipedia.org/wiki/Template_(C%2B%2B)">Template-Programmierung</a> Funktionen möglich, die mehrere Arrays entgegennehmen und verarbeiten ein Beispiel ist folgendem Codeblock zu entnehmen:
</p>
<div class="org-src-container">
<pre class="src src-cuda">// SPARSE MATRIX DIVISION
// SPARSE MATRIX-FORM IS IN TUPLE
// DIVIDE THE TUPLE BY A 1D-SEQUENCE
struct sparseDiMatrixDivision
{
    __host__ __device__
    thrust::tuple&lt;float,float&gt; operator()(const thrust::tuple&lt;float,float&gt;&amp; spMat, const thrust::tuple&lt;float&gt; &amp;divi) const
    {
      auto out = thrust::make_tuple(thrust::get&lt;0&gt;(spMat)/thrust::get&lt;0&gt;(divi),thrust::get&lt;1&gt;(spMat)/thrust::get&lt;0&gt;(divi));
      return out;
    }

};

</pre>
</div>

<p>
Die Funktion gibt ein Tuple des Typs &lt;float, float&gt; wieder. In der Eingabe nimmt sie ein 2D-Tuple mit &lt;float,float&gt; and und ein 1D-Tuple &lt;float&gt;.
Im Funktionsbody berechnet sie die Division des 2D-Tuples durch des 1D-Tuples. Wird dieses <b>struct-Objekt</b> erstellt, speichert es außderdem einen Zustand zur Laufzeit
des Programms. Die Funktion erlaubt auch den Einsatz von Iteratoren, d.h. Container vom Typ Vector&lt;float&gt; können durch diese Funktion gezogen werden. Die Werte in den
Containern werden entsprechend der Funktionsvorschrift miteinander verrechnet.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd8eae65" class="outline-2">
<h2 id="orgd8eae65"><span class="todo TODO">TODO</span> Besser erklären: Konzeptzeichnung bzw. Beispielcode. <span class="timestamp-wrapper"><span class="timestamp">&lt;2023-03-07 Tue&gt;</span></span>shoshin</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>
</div>
</body>
</html>
