<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arbeitsproben</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Arbeitsproben</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org367cc23">Numerische Berechnungen von Elektro-magnetischen Phänomenen</a></li>
<li><a href="#orgacfe318">Die harmonische Störung des dielektrischen Feldes</a>
<ul>
<li><a href="#org09a7356">Codebeispiel: Die Sinusfunktion eine Lösung des freien Feldes</a></li>
</ul>
</li>
<li><a href="#orgb0c41e5">Lösung der Wellengleichung in endlichen Geometrien</a>
<ul>
<li><a href="#org3237b60">Potential in einem Zylinder</a></li>
</ul>
</li>
<li><a href="#org701fe67">Bestimmte Harmonische: Flüstergaleriemoden</a>
<ul>
<li><a href="#org5c69bb0">Allgemeine Funktion der 3D-Wellengleichung</a></li>
<li><a href="#org2777700">Die Azimutale Funktion</a>
<ul>
<li><a href="#org6b59f14">Codebeispiel: Azimutale Funktion</a></li>
</ul>
</li>
<li><a href="#org12bd415">Funktion der Z-Koordinate bzw. der Höhe</a>
<ul>
<li><a href="#org3ff3220">Codebeispiel für die vertikale Richtung</a></li>
</ul>
</li>
<li><a href="#org0ff5e4e">Die Radiale Funktion</a>
<ul>
<li><a href="#org80b566b">Codebeispiel der Besselfunktionen</a></li>
<li><a href="#org71bae08">Codebeispiel der radialen Funktion innerhalb des Resonators</a></li>
<li><a href="#org87d89bd">Codebeispiel der radialen Funktion außerhalb des Resonators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgde7dc19">Numerische Approximation</a>
<ul>
<li><a href="#org7a50d2d">Codebeispiel:</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org367cc23" class="outline-2">
<h2 id="org367cc23">Numerische Berechnungen von Elektro-magnetischen Phänomenen</h2>
<div class="outline-text-2" id="text-org367cc23">
<p>
Auf dieser Site stelle ich vor, wie ein physikalisches Phänomen - nämlich die Lichtausbreitung in dielektrischen, runden Resonatoren
und wie sie mathematisch beschrieben werden kann. Dabei kommen Theorie und Code-Beispiele zum Einsatz. Im Resultat werden Lösungen von
Differentialgleichungen mit einem numerischen Verfahren vorgestellt. <b>Hinweis:</b> momentan ist dieser Code noch in einem anderen <a href="https://github.com/shosh1n/EMCuda">Repository</a>.
Das Phänomen, welches hier maßgeblich beschrieben werden soll, ist das Phänomen der Flüstergaleriemoden.
</p>
</div>
</div>

<div id="outline-container-orgacfe318" class="outline-2">
<h2 id="orgacfe318">Die harmonische Störung des dielektrischen Feldes</h2>
<div class="outline-text-2" id="text-orgacfe318">
<p>
Zunächst wird im Zuge auf die Ausbreitung des Lichts festgelegt, dass nur harmonische Veränderungen des Feldes betrachtet werden. D.h. dass periodische Veränderungen
des Feldes durch Sinus- und Cosinusfunktionen beschrieben werden können. Mathematisch generell &ldquo;gesprochen&rdquo; kommen die periodischen Schwinungen aus der Wellengleichung:
</p>

\begin{equation}
     \Delta\mathbf{E} - \frac{1}{c_{m}^{2}}\frac{\partial^{2}E}{\partial t^{2}} = 0
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(\Delta\)</td>
<td class="org-left">Laplace-Operator</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{E}\)</td>
<td class="org-left">Elektrische Feld</td>
</tr>

<tr>
<td class="org-left">\(c_{m}\)</td>
<td class="org-left">Lichtgeschwindigkeit im Medium</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{k}\)</td>
<td class="org-left">Wellenvektor</td>
</tr>

<tr>
<td class="org-left">\(j\)</td>
<td class="org-left">Imaginäre Einheit</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{r}\)</td>
<td class="org-left">Ortsvektor</td>
</tr>

<tr>
<td class="org-left">\(\omega\)</td>
<td class="org-left">Kreisfrequenz: \hspace{.5mm} \(2\pi f\)</td>
</tr>

<tr>
<td class="org-left">\(t\)</td>
<td class="org-left">Zeiteinheit</td>
</tr>
</tbody>
</table>

<p>
Allgemein kann das elektrische <b>Freie Feld</b> über folgenden algebraischen Ausdruck zusammengefasst werden:
</p>
\begin{equation}
    \mathbf{E} (\mathbf{r},t) = E(\mathbf{z},t)
    = E_{0}\exp{j\mathbf{k}\cdot\mathbf{r}-j\omega t}
\end{equation}
</div>
<div id="outline-container-org09a7356" class="outline-3">
<h3 id="org09a7356">Codebeispiel: Die Sinusfunktion eine Lösung des freien Feldes</h3>
<div class="outline-text-3" id="text-org09a7356">
<p>
Eine einfache Lösung der Wellengleichung ist die Sinusfunktion. Durch diese können periodische Schwankungen am Ort oder in der Zeit beschrieben werden.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> matplotlib
matplotlib.use(<span style="font-style: italic;">'Agg'</span>)
<span style="font-weight: bold;">import</span> scipy.special <span style="font-weight: bold;">as</span> sp
<span style="font-weight: bold;">import</span> matplotlib.pyplot <span style="font-weight: bold;">as</span> plt

<span style="font-weight: bold; font-style: italic;">x</span>  = np.linspace(0, 20, 100)

<span style="font-weight: bold;">for</span> n <span style="font-weight: bold;">in</span> <span style="font-weight: bold;">range</span>(1):
    <span style="font-weight: bold; font-style: italic;">y</span> = np.sin(x);
    plt.plot(x,y,label=r<span style="font-style: italic;">'$Sin(x)$'</span>)

plt.axhline(0,color=<span style="font-style: italic;">'green'</span>, label=<span style="font-style: italic;">'_nolegend_'</span>)
plt.grid()
plt.legend()
plt.xlabel(<span style="font-style: italic;">'$x$'</span>)
plt.ylabel(<span style="font-style: italic;">'${Sin}(x)$'</span>)
plt.title(r<span style="font-style: italic;">'Die Harmonische Schwingung - Sinusfunktion $Sin(x)$'</span>)
plt.savefig(<span style="font-style: italic;">'img/matplot-fig.png'</span>)
<span style="font-weight: bold;">return</span> <span style="font-style: italic;">'img/matplot-fig.png'</span>

</pre>
</div>




<div id="orgc649c4e" class="figure">
<p><img src="./img/matplot-fig.png" alt="1DSinus" title="Sinus" align="center" />
</p>
<p><span class="figure-number">Figure 1: </span>Eine 1D-Sinusfunktion</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgb0c41e5" class="outline-2">
<h2 id="orgb0c41e5">Lösung der Wellengleichung in endlichen Geometrien</h2>
<div class="outline-text-2" id="text-orgb0c41e5">
<p>
Zu Beginn des Textes wurde die Wellengleichung ohne große Einschränkungen gelöst. In realen Systemen ist so eine Lösung ungenau. In einem unendlich großen
störungsfreien Raum, stellt die 1D-Sinusfunktion eine gültige Lösung dar.
Für endliche Räume müssen weitere Berücksichtigungen getroffen werden. Eine einfache Geometrie für Resonatoren ist ein Zylinder.
Ein Zylinder hat schon 3-Raumkoordinaten. Um die periodische Störung zu lösen müssen entsprechend dieser Raumkoordinaten Funktionen gefunden werden, die den
Zylinderraum vollständig beschreiben können.
</p>
</div>

<div id="outline-container-org3237b60" class="outline-3">
<h3 id="org3237b60">Potential in einem Zylinder</h3>
<div class="outline-text-3" id="text-org3237b60">
<p>
Da eine Störung eine Veränderung herbeiführt, wird ein Differentialoperator auf eine Größe \(\psi\) angewandt. Dieser beschreibende Veränderungsoperator berücksichtigt
die 3-Raumrichtungen und hat folgende Funktionsvorschrift:
</p>

\begin{equation}\label{eqn:ZylinderWelle}
    -\frac{1}{2}\Big[ \frac{1}{\rho} \frac{\partial}{\partial \rho} \Big( \rho \frac{\partial}{\partial \rho} \Big) + \frac{1}{\rho^{2}}\frac{\partial^{2}}{\partial \varphi^{2}} + \frac{\partial^{2}}{\partial z^{2}} \Big] \psi = L\psi
\end{equation}
</div>
</div>
</div>



<div id="outline-container-org701fe67" class="outline-2">
<h2 id="org701fe67">Bestimmte Harmonische: Flüstergaleriemoden</h2>
<div class="outline-text-2" id="text-org701fe67">
<p>
Flüstergaleriemoden sind auch bestimmte Harmonische Störungen im Raum. Sie sind an der Seitenwand eines Resonators zu verorten. Ihre Entdeckung beruht auf einer akustischen Beobachtung von Schallwellen,
die an der Wand einer Kuppel reflektiert werden, d.h. die Schallausbreitung findet über Reflektion der Schallwellen an der Kuppelwand statt.
Ist die Wellenlänge sind bestimmte Größen des System bekannt, dann Eine Wellenzahl - oder auch ein quantisierter Zustand der Harmonischen Störung
bestimmt werden.
</p>
</div>

<div id="outline-container-org5c69bb0" class="outline-3">
<h3 id="org5c69bb0">Allgemeine Funktion der 3D-Wellengleichung</h3>
<div class="outline-text-3" id="text-org5c69bb0">
<p>
Im Besten Fall kann eine Wellenfunktion gefunden werden, die sich aus 3 einzelnen Funktionen entsprechend der Raumkoordinaten zusammensetzt.
Ohne große Überlegung kann die Funktion folgendermaßen geschrieben werden:
</p>

\begin{equation}\label{eqn:ZylinderPotential}
    \psi = R(\rho)Z(z)\Phi(\varphi).
\end{equation}

<p>
In den folgenden Abschnitte werden diese Funktionen einzeln betrachtet.
</p>
</div>
</div>

<div id="outline-container-org2777700" class="outline-3">
<h3 id="org2777700">Die Azimutale Funktion</h3>
<div class="outline-text-3" id="text-org2777700">
<p>
Als erstes lässt sich relativ einfach die azimutale Funktion bestimmen. Die Azimutale Funktion umläuft den Zylinder.
Folgendes Codebeispiel veranschautlicht diese.
</p>
</div>

<div id="outline-container-org6b59f14" class="outline-4">
<h4 id="org6b59f14">Codebeispiel: Azimutale Funktion</h4>
<div class="outline-text-4" id="text-org6b59f14">
<div class="org-src-container">
<pre class="src src-python">

<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> matplotlib
matplotlib.use(<span style="font-style: italic;">'Agg'</span>)
<span style="font-weight: bold;">from</span> matplotlib.patches <span style="font-weight: bold;">import</span> FancyArrowPatch
<span style="font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="font-weight: bold;">import</span> proj3d
<span style="font-weight: bold;">import</span> mpl_toolkits.mplot3d.art3d <span style="font-weight: bold;">as</span> art3d
<span style="font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="font-weight: bold;">import</span> Axes3D
<span style="font-weight: bold;">from</span> matplotlib.patches <span style="font-weight: bold;">import</span> Circle
<span style="font-weight: bold;">from</span> matplotlib <span style="font-weight: bold;">import</span> pyplot <span style="font-weight: bold;">as</span> plt

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Define a class for the coordinate-system</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Arrow3D</span>(FancyArrowPatch):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, xs, ys, zs, *args, **kwargs):
        <span style="font-weight: bold;">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span style="font-weight: bold;">self</span>._verts3d = xs, ys, zs

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">do_3d_projection</span>(<span style="font-weight: bold;">self</span>, renderer=<span style="font-weight: bold; text-decoration: underline;">None</span>):
        <span style="font-weight: bold; font-style: italic;">xs3d</span>, <span style="font-weight: bold; font-style: italic;">ys3d</span>, <span style="font-weight: bold; font-style: italic;">zs3d</span> = <span style="font-weight: bold;">self</span>._verts3d
        <span style="font-weight: bold; font-style: italic;">xs</span>, <span style="font-weight: bold; font-style: italic;">ys</span>, <span style="font-weight: bold; font-style: italic;">zs</span> = proj3d.proj_transform(xs3d, ys3d, zs3d, <span style="font-weight: bold;">self</span>.axes.M)
        <span style="font-weight: bold;">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span style="font-weight: bold;">return</span> np.<span style="font-weight: bold;">min</span>(zs)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">This Function will draw a cylinder</span>
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">plot_3D_cylinder</span>(radius, height, elevation=0, resolution=100, color=<span style="font-style: italic;">'b'</span>, x_center = 0, y_center = 0):

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">init where to draw the projections</span>
    <span style="font-weight: bold; font-style: italic;">fig</span>=plt.figure(figsize=(5,5))
    <span style="font-weight: bold; font-style: italic;">ax</span> = Axes3D(fig, azim=45, elev=21)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">take values from the function input</span>
    <span style="font-weight: bold; font-style: italic;">x</span> = np.linspace(x_center-radius, x_center+radius, resolution)
    <span style="font-weight: bold; font-style: italic;">z</span> = np.linspace(elevation, elevation+height, resolution)
    <span style="font-weight: bold; font-style: italic;">X</span>, <span style="font-weight: bold; font-style: italic;">Z</span> = np.meshgrid(x, z)

    <span style="font-weight: bold; font-style: italic;">theta</span> = np.linspace(-1 * np.pi, 1 * np.pi, 1000)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">coordinate conversion cartesain x_,y_,z_ in cylindrical</span>
    <span style="font-weight: bold; font-style: italic;">R</span> = 1
    <span style="font-weight: bold; font-style: italic;">x_</span> = radius * np.cos(theta)+x_center
    <span style="font-weight: bold; font-style: italic;">y_</span> = radius *np.sin(theta)+y_center
    <span style="font-weight: bold; font-style: italic;">z_</span> = np.sin(18*theta)
    <span style="font-weight: bold; font-style: italic;">Y</span> = np.sqrt(radius**2 - (X - x_center)**2) + y_center <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Pythagorean theorem</span>


    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Color the cylinder surface-patches</span>
    ax.plot_surface(X, Y, Z,alpha=0.3, linewidth=0, color=<span style="font-style: italic;">'deepskyblue'</span>)
    ax.plot_surface(X, (2*y_center-Y), Z,alpha=0.2, linewidth=0, color=<span style="font-style: italic;">'lightskyblue'</span>)
    <span style="font-weight: bold; font-style: italic;">floor</span> = Circle((x_center, y_center), radius, color=<span style="font-style: italic;">'deepskyblue'</span>,alpha=0.3)
    ax.add_patch(floor)
    art3d.pathpatch_2d_to_3d(floor, z=elevation, zdir=<span style="font-style: italic;">"z"</span>)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Color the circle-surfaces</span>
    <span style="font-weight: bold; font-style: italic;">ceiling</span> = Circle((x_center, y_center), radius, color=<span style="font-style: italic;">'deepskyblue'</span>,alpha=0.5)
    ax.add_patch(ceiling)
    art3d.pathpatch_2d_to_3d(ceiling, z=elevation+height, zdir=<span style="font-style: italic;">"z"</span>)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Plot the encircling function</span>
    ax.plot(x_, y_, z_, color = <span style="font-style: italic;">'fuchsia'</span>)

    <span style="font-weight: bold; font-style: italic;">arrow_prop_dict</span> = <span style="font-weight: bold;">dict</span>(mutation_scale=20, arrowstyle=<span style="font-style: italic;">'-&gt;'</span>, shrinkA=0, shrinkB=0)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Add an arrow that outlines the function's path</span>
    <span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 79], [0, 15], [0, 2.8], **arrow_prop_dict, color=<span style="font-style: italic;">'darkorchid'</span>, linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=3.0)
    ax.add_artist(a)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Add a red orthogonal arrow in the \rho respectively y-direction</span>
    <span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 75], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'red'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Add a black arrow indicating the y-cartesain coordinate</span>
    <span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 95], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Add a black arrow indicating the x-cartesain coordinate</span>
    <span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 95], [0, 0], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Add a black arrow indicating the z-direction</span>
    <span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 0], [0, 6.8], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Add a blue arrow indicating the z-direction</span>
    <span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 0], [0, 6], **arrow_prop_dict, color=<span style="font-style: italic;">'blue'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">add letters for orientation o-origin, \rho etc. ...</span>
    ax.text(3, 0.0, -.35, r<span style="font-style: italic;">'$o$'</span>)
    ax.text(0, 75, 0, r<span style="font-style: italic;">'$\rho$'</span>)
    ax.text(60, 60, 0, r<span style="font-style: italic;">'$\varphi$'</span>)
    ax.text(0, -2, 7, r<span style="font-style: italic;">'$z$'</span>)
    ax.text(107, 15, 3.4, r<span style="font-style: italic;">'$\psi(\rho,z,\varphi)$'</span>)
    ax.text(100, 0, 0, r<span style="font-style: italic;">'$x$'</span>)
    ax.text(0, 98, 0, r<span style="font-style: italic;">'$y$'</span>)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Now draw the \varphi-axis *hint: it's angle dependent 'cause it's a cylinder</span>
    <span style="font-weight: bold; font-style: italic;">thetaAng</span> = np.linspace(0,np.pi/2,100)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">0 &lt;= &#952; &lt;= 2&#960;</span>
    <span style="font-weight: bold; font-style: italic;">rAng</span> =  50.0 <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">circle radius</span>
    <span style="font-weight: bold; font-style: italic;">x1</span> = rAng * np.cos(thetaAng) + 0
    <span style="font-weight: bold; font-style: italic;">x2</span> = rAng * np.sin(thetaAng) + 0

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">Plot this axis as a function and make it green</span>
    ax.plot(x1, x2, color=<span style="font-style: italic;">'g'</span>,linewidth=5.0)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">name the axis</span>
    ax.set_xlabel(<span style="font-style: italic;">'x-Achse'</span>, fontsize=16)
    ax.set_ylabel(<span style="font-style: italic;">'y-Achse'</span>, fontsize=16)
    ax.set_zlabel(<span style="font-style: italic;">'z-Achse'</span>, fontsize=16)


    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">set a limit on the z-axis/**sorry it's messy &lt;2023-03-02 Thu&gt; shoshin</span>
    ax.set_zlim(-4,4)

    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">clean the canvas no grid whatsoever or other oob stuff</span>
    <span style="font-weight: bold; font-style: italic;">ax.xaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
    <span style="font-weight: bold; font-style: italic;">ax.yaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
    <span style="font-weight: bold; font-style: italic;">ax.zaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
    ax.xaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
    ax.yaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
    ax.zaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)

    ax.grid(<span style="font-weight: bold; text-decoration: underline;">False</span>)
    <span style="font-weight: bold; font-style: italic;">font</span> = {<span style="font-style: italic;">'family'</span> : <span style="font-style: italic;">'sans-serif'</span>,
        <span style="font-style: italic;">'weight'</span> : <span style="font-style: italic;">'normal'</span>,
        <span style="font-style: italic;">'size'</span>   : 20}
    plt.rc(<span style="font-style: italic;">'font'</span>, **font)
    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">fig.suptitle("Zylindrische Kavit&#228;t", fontsize=25)</span>
    plt.axis(<span style="font-style: italic;">'off'</span>)
    <span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">fig.savefig('ZylinderSystem.png', dpi=320)</span>
    plt.show()

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create a figure for plotting</span>
<span style="font-weight: bold; font-style: italic;">fig</span> = plt.figure()

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create a 3d ax-element</span>
<span style="font-weight: bold; font-style: italic;">ax</span> = fig.add_subplot(111, projection=<span style="font-style: italic;">'3d'</span>)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">adjust view on the art-piece</span>
ax.view_init(azim=-90, elev=90)
ax.set_axis_off()
plt.show()


<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">Write parameters to be passed to above cylinder function</span>
<span style="font-weight: bold; font-style: italic;">radius</span> = 50
<span style="font-weight: bold; font-style: italic;">height</span> = 2
<span style="font-weight: bold; font-style: italic;">elevation</span> = -1
<span style="font-weight: bold; font-style: italic;">resolution</span> = 100
<span style="font-weight: bold; font-style: italic;">color</span> = <span style="font-style: italic;">'lightskyblue'</span>
<span style="font-weight: bold; font-style: italic;">x_center</span> = 0
<span style="font-weight: bold; font-style: italic;">y_center</span> = 0

<span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">pass the parameter</span>
plot_3D_cylinder(radius, height, elevation=elevation, resolution=resolution, color=color, x_center=x_center, y_center=y_center)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">save the figure</span>
plt.savefig(<span style="font-style: italic;">'img/matplot-azimuthal.png'</span>)
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">return 'img/matplot-azimuthal.png'</span>


</pre>
</div>

<p>
<a href="None">None</a>
</p>


<div id="org5ecc151" class="figure">
<p><img src="./img/matplot-azimuthal.png" alt="matplot-azimuthal.png" title="AzimutaleFunktion" align="center" />
</p>
<p><span class="figure-number">Figure 2: </span>Die azimutale Funktion beschreibt die Umlaufrichtung</p>
</div>

\begin{equation}\label{eqn:azimuthal-Zahl}
  m = \frac{2\pi r n_{m}}{\lambda_{0}}
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(m\)</td>
<td class="org-left">Azimutale Quantenzahl</td>
</tr>

<tr>
<td class="org-left">\(r\)</td>
<td class="org-left">Radius</td>
</tr>

<tr>
<td class="org-left">\(n_{m}\)</td>
<td class="org-left">Brechungsindex</td>
</tr>
</tbody>
</table>

<p>
Der mathematische Ausdruck ist im Vergleich zum oberen Codebeispiel ziemlich unspektakulär:
</p>
\begin{equation}
     \Phi(\varphi) = e^{(jm \varphi)}
\end{equation}
</div>
</div>
</div>

<div id="outline-container-org12bd415" class="outline-3">
<h3 id="org12bd415">Funktion der Z-Koordinate bzw. der Höhe</h3>
<div class="outline-text-3" id="text-org12bd415">
<p>
Für die Funktion \(Z(z)\) ergeben sich unterschiedliche Funktionen. Symmetrische, auch als unsymmetrische  Funktionen.
Das Liegt daran, dass sowohl Cosinus als auch Sinus zulässig sind.
</p>


\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
       A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big),   & \text{für } z < - \bigg(\frac{h}{2}\bigg) .\\
       B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big), & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
       A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg)
        \end{array}\right.
\end{equation}

<p>
und unsymmetrischen Lösungen:
</p>

\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
        A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z \Big),   & \text{für } z < -\bigg(\frac{h}{2}\bigg) .\\
        B sin\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big) , & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
        - A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg).
        \end{array}\right.
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="Wellenzahlen" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(k_{eff}\)</td>
<td class="org-left">effektive Wellenzahl einer Mode</td>
</tr>

<tr>
<td class="org-left">\(k_{i}\)</td>
<td class="org-left">Wellenzahl im Festkörper</td>
</tr>

<tr>
<td class="org-left">\(k_{0}\)</td>
<td class="org-left">Wellenzahl im Vakuum</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">Höhe eines Resonators</td>
</tr>
</tbody>
</table>

<p>
Die Höhe \(h\) gibt die Randbedingung für die Gültigkeit der Sinus/Cosinus Funktion für die $Z$-Koordinate wieder. Jenseits einer gegebenen Höhe sind andere Funktionen definiert, die mit zunehmendem/abnehmenden \(z\) exponential abfallen und gegen \(0\) gehen.
</p>
</div>

<div id="outline-container-org3ff3220" class="outline-4">
<h4 id="org3ff3220">Codebeispiel für die vertikale Richtung</h4>
</div>
</div>

<div id="outline-container-org0ff5e4e" class="outline-3">
<h3 id="org0ff5e4e">Die Radiale Funktion</h3>
<div class="outline-text-3" id="text-org0ff5e4e">
<p>
Für die radiale Funktion \(R(\rho)\) ergibt sich durch die Separation der Variablen Bessels-Differentialgleichung.
</p>

\begin{equation}\label{eqn:PreBessel}
    \rho^{2}\Big( \frac{d^{2}R}{d \rho^{2}}\Big) + (\rho^{2}k^{2}-m^{2})R = 0
\end{equation}

<p>
Durch die Substitution \(\mathbf{k \rho = x}\) ist der Ausdruck aus Gleichung als die allgemeine Form darstellbar.
</p>

\begin{equation}
    x^{2}\frac{d^{2}R}{dx^{2}}+\frac{dR}{dx}+(x^{2}-m^{2})R = 0
\end{equation}

<p>
Diese Differentialgleichung kann durch Besselfunktionen und Hankelfunktionen erster Gattung gelöst werden. Das Innere des Resonators wird dabei durch Besselfunktionen beschrieben.
</p>
\begin{equation}
   R(\rho) = J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big), \hspace{0.5cm} \rho < r
\end{equation}
</div>


<div id="outline-container-org80b566b" class="outline-4">
<h4 id="org80b566b">Codebeispiel der Besselfunktionen</h4>
<div class="outline-text-4" id="text-org80b566b">
<p>
Im Folgenden wird in Python ein Codebeispiel gezeigt, in welchem das Innere eines Resonators dargestellt wird. Es veranschaulicht eine radiale Veränderung des Elektromagnetischen Feldes.
</p>
</div>
</div>

<div id="outline-container-org71bae08" class="outline-4">
<h4 id="org71bae08">Codebeispiel der radialen Funktion innerhalb des Resonators</h4>
<div class="outline-text-4" id="text-org71bae08">
<div class="org-src-container">
<pre class="src src-python">
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> scipy.special <span style="font-weight: bold;">as</span> sp
<span style="font-weight: bold;">import</span> matplotlib
<span style="font-weight: bold;">from</span> scipy.special <span style="font-weight: bold;">import</span> hankel1e, y1_zeros
<span style="font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="font-weight: bold;">import</span> Axes3D
matplotlib.use(<span style="font-style: italic;">'Agg'</span>)
<span style="font-weight: bold;">import</span> matplotlib.pyplot <span style="font-weight: bold;">as</span> plt
<span style="font-weight: bold;">from</span> matplotlib.patches <span style="font-weight: bold;">import</span> FancyArrowPatch
<span style="font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="font-weight: bold;">import</span> proj3d

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">needed for 3D-coordinate system</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Arrow3D</span>(FancyArrowPatch):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, xs, ys, zs, *args, **kwargs):
        <span style="font-weight: bold;">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span style="font-weight: bold;">self</span>._verts3d = xs, ys, zs

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">do_3d_projection</span>(<span style="font-weight: bold;">self</span>, renderer=<span style="font-weight: bold; text-decoration: underline;">None</span>):
        <span style="font-weight: bold; font-style: italic;">xs3d</span>, <span style="font-weight: bold; font-style: italic;">ys3d</span>, <span style="font-weight: bold; font-style: italic;">zs3d</span> = <span style="font-weight: bold;">self</span>._verts3d
        <span style="font-weight: bold; font-style: italic;">xs</span>, <span style="font-weight: bold; font-style: italic;">ys</span>, <span style="font-weight: bold; font-style: italic;">zs</span> = proj3d.proj_transform(xs3d, ys3d, zs3d, <span style="font-weight: bold;">self</span>.axes.M)
        <span style="font-weight: bold;">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span style="font-weight: bold;">return</span> np.<span style="font-weight: bold;">min</span>(zs)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">using circular coordinates again! range of theta-axis is needed</span>
<span style="font-weight: bold; font-style: italic;">thetaAng</span> = np.linspace(0,np.pi/2,100)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">0 &lt;= &#952; &lt;= 2&#960;</span>

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">assume the edge of the resonator to be rAng = 50</span>
<span style="font-weight: bold; font-style: italic;">rAng</span> =  50.0
<span style="font-weight: bold; font-style: italic;">x1</span> = rAng * np.cos(thetaAng) + 0
<span style="font-weight: bold; font-style: italic;">x2</span> = rAng * np.sin(thetaAng) + 0

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">prepare the canvas and axis for the function</span>
<span style="font-weight: bold; font-style: italic;">fig</span>=plt.figure(figsize=(5,5))
<span style="font-weight: bold; font-style: italic;">ax</span> = Axes3D(fig, azim=45, elev=21)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create coordinate arrows for cylindrical and cartesian directions</span>
<span style="font-weight: bold; font-style: italic;">arrow_prop_dict</span> = <span style="font-weight: bold;">dict</span>(mutation_scale=20, arrowstyle=<span style="font-style: italic;">'-&gt;'</span>, shrinkA=0, shrinkB=0)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span style="font-style: italic;">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span style="font-style: italic;">'g'</span>,linewidth=5.0)


<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span style="font-style: italic;">'$o$'</span>)
ax.text(0, 55, 0, r<span style="font-style: italic;">'$\rho$'</span>)
ax.text(45, 45, 0, r<span style="font-style: italic;">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span style="font-style: italic;">'$z$'</span>)
ax.text(75, 0, 0, r<span style="font-style: italic;">'$x$'</span>)
ax.text(0, 70, 0, r<span style="font-style: italic;">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span style="font-style: italic;">'$R(\rho)$'</span>)


<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create the bessel-function</span>
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">drumhead_height</span>(n, k, distance, angle, t):

   <span style="font-weight: bold; font-style: italic;">kth_zero</span> = sp.jn_zeros(n, k)[-1]

   <span style="font-weight: bold;">return</span> np.cos(t) * np.cos(n*angle) * sp.jn(n, distance*kth_zero)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
<span style="font-weight: bold; font-style: italic;">theta</span> = np.r_[0:2*np.pi:50j]
<span style="font-weight: bold; font-style: italic;">radius</span> = np.r_[0:50:50j]

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">transform cartesian coordinates into cylindrical ones</span>
<span style="font-weight: bold; font-style: italic;">x</span> = np.array([r * np.cos(theta) <span style="font-weight: bold;">for</span> r <span style="font-weight: bold;">in</span> radius])
<span style="font-weight: bold; font-style: italic;">y</span> = np.array([r * np.sin(theta) <span style="font-weight: bold;">for</span> r <span style="font-weight: bold;">in</span> radius])
<span style="font-weight: bold; font-style: italic;">z</span> = np.array([drumhead_height(0,2, r, theta,1) <span style="font-weight: bold;">for</span> r <span style="font-weight: bold;">in</span> radius])


<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span style="font-style: italic;">'jet'</span>,alpha=0.5)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">set axis names and labels</span>
ax.set_xlabel(<span style="font-style: italic;">'x'</span>)
ax.set_ylabel(<span style="font-style: italic;">'y'</span>)
ax.set_zlabel(<span style="font-style: italic;">'z'</span>)

ax.set_xlabel(<span style="font-style: italic;">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span style="font-style: italic;">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span style="font-style: italic;">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">strip the figure of unnecessary stuff</span>
<span style="font-weight: bold; font-style: italic;">ax.xaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
<span style="font-weight: bold; font-style: italic;">ax.yaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
<span style="font-weight: bold; font-style: italic;">ax.zaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
ax.xaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
<span style="font-weight: bold; font-style: italic;">font</span> = {<span style="font-style: italic;">'family'</span> : <span style="font-style: italic;">'sans-serif'</span>,
        <span style="font-style: italic;">'weight'</span> : <span style="font-style: italic;">'normal'</span>,
        <span style="font-style: italic;">'size'</span>   : 20}
plt.rc(<span style="font-style: italic;">'font'</span>, **font)
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span style="font-style: italic;">'off'</span>)
fig.tight_layout(pad=1.0)
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span style="font-style: italic;">'./img/BRadialeFunktion.png'</span>)
plt.show()



</pre>
</div>


<div id="org4f3ece3" class="figure">
<p><img src="./img/BRadialeFunktion.png" alt="BRadialeFunktion.png" title="Bessel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 3: </span>Die Funktion die radial die Umlaufrichtung beschreibt</p>
</div>
</div>
</div>


<div id="outline-container-org87d89bd" class="outline-4">
<h4 id="org87d89bd">Codebeispiel der radialen Funktion außerhalb des Resonators</h4>
<div class="outline-text-4" id="text-org87d89bd">
<p>
Außerhalb der endlichen Geometrie des Resonator fallen die Ausprägungen des elektromagntischen Feldes stark ab. Durch Hankelfunktionen wird diesem Umstand mathematisch
Rechung getragen.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span style="font-weight: bold;">import</span> numpy <span style="font-weight: bold;">as</span> np
<span style="font-weight: bold;">import</span> scipy.special <span style="font-weight: bold;">as</span> sp
<span style="font-weight: bold;">import</span> matplotlib
<span style="font-weight: bold;">from</span> scipy.special <span style="font-weight: bold;">import</span> hankel1e, y1_zeros
<span style="font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="font-weight: bold;">import</span> Axes3D
matplotlib.use(<span style="font-style: italic;">'Agg'</span>)
<span style="font-weight: bold;">import</span> matplotlib.pyplot <span style="font-weight: bold;">as</span> plt
<span style="font-weight: bold;">from</span> matplotlib.patches <span style="font-weight: bold;">import</span> FancyArrowPatch
<span style="font-weight: bold;">from</span> mpl_toolkits.mplot3d <span style="font-weight: bold;">import</span> proj3d

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">needed for 3D-coordinate system</span>
<span style="font-weight: bold;">class</span> <span style="font-weight: bold; text-decoration: underline;">Arrow3D</span>(FancyArrowPatch):
    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">__init__</span>(<span style="font-weight: bold;">self</span>, xs, ys, zs, *args, **kwargs):
        <span style="font-weight: bold;">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span style="font-weight: bold;">self</span>._verts3d = xs, ys, zs

    <span style="font-weight: bold;">def</span> <span style="font-weight: bold;">do_3d_projection</span>(<span style="font-weight: bold;">self</span>, renderer=<span style="font-weight: bold; text-decoration: underline;">None</span>):
        <span style="font-weight: bold; font-style: italic;">xs3d</span>, <span style="font-weight: bold; font-style: italic;">ys3d</span>, <span style="font-weight: bold; font-style: italic;">zs3d</span> = <span style="font-weight: bold;">self</span>._verts3d
        <span style="font-weight: bold; font-style: italic;">xs</span>, <span style="font-weight: bold; font-style: italic;">ys</span>, <span style="font-weight: bold; font-style: italic;">zs</span> = proj3d.proj_transform(xs3d, ys3d, zs3d, <span style="font-weight: bold;">self</span>.axes.M)
        <span style="font-weight: bold;">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span style="font-weight: bold;">return</span> np.<span style="font-weight: bold;">min</span>(zs)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">using circular coordinates again! range of theta-axis is needed</span>
<span style="font-weight: bold; font-style: italic;">thetaAng</span> = np.linspace(0,np.pi/2,100)  <span style="font-weight: bold; font-style: italic;"># </span><span style="font-weight: bold; font-style: italic;">0 &lt;= &#952; &lt;= 2&#960;</span>

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">assume the edge of the resonator to be rAng = 50</span>
<span style="font-weight: bold; font-style: italic;">rAng</span> =  50.0
<span style="font-weight: bold; font-style: italic;">x1</span> = rAng * np.cos(thetaAng) + 0
<span style="font-weight: bold; font-style: italic;">x2</span> = rAng * np.sin(thetaAng) + 0

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">prepare the canvas and axis for the function</span>
<span style="font-weight: bold; font-style: italic;">fig</span>=plt.figure(figsize=(5,5))
<span style="font-weight: bold; font-style: italic;">ax</span> = Axes3D(fig, azim=45, elev=21)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create coordinate arrows for cylindrical and cartesian directions</span>
<span style="font-weight: bold; font-style: italic;">arrow_prop_dict</span> = <span style="font-weight: bold;">dict</span>(mutation_scale=20, arrowstyle=<span style="font-style: italic;">'-&gt;'</span>, shrinkA=0, shrinkB=0)

<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span style="font-style: italic;">'black'</span>,linestyle=<span style="font-style: italic;">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span style="font-style: italic;">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
<span style="font-weight: bold; font-style: italic;">a</span> = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span style="font-style: italic;">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span style="font-style: italic;">'g'</span>,linewidth=5.0)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span style="font-style: italic;">'$o$'</span>)
ax.text(0, 55, 0, r<span style="font-style: italic;">'$\rho$'</span>)
ax.text(45, 45, 0, r<span style="font-style: italic;">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span style="font-style: italic;">'$z$'</span>)
ax.text(75, 0, 0, r<span style="font-style: italic;">'$x$'</span>)
ax.text(0, 70, 0, r<span style="font-style: italic;">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span style="font-style: italic;">'$R(\rho)$'</span>)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">create the hankel-function</span>
<span style="font-weight: bold;">def</span> <span style="font-weight: bold;">drumhead_height</span>(n, k, distance, angle, t):

   <span style="font-weight: bold; font-style: italic;">kth_zero</span> = sp.jn_zeros(n, k)[-1]

   <span style="font-weight: bold;">return</span> np.cos(t) * np.cos(n*angle) * sp.hankel1e(n, distance*kth_zero)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
<span style="font-weight: bold; font-style: italic;">theta</span> = np.r_[0:2*np.pi:50j]
<span style="font-weight: bold; font-style: italic;">radius</span> = np.r_[55:75:50j]

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">transform cartesian coordinates into cylindrical ones</span>
<span style="font-weight: bold; font-style: italic;">x</span> = np.array([r * np.cos(theta) <span style="font-weight: bold;">for</span> r <span style="font-weight: bold;">in</span> radius])
<span style="font-weight: bold; font-style: italic;">y</span> = np.array([r * np.sin(theta) <span style="font-weight: bold;">for</span> r <span style="font-weight: bold;">in</span> radius])
<span style="font-weight: bold; font-style: italic;">z</span> = np.array([drumhead_height(0,2, r, theta,1) <span style="font-weight: bold;">for</span> r <span style="font-weight: bold;">in</span> radius])

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span style="font-style: italic;">'jet'</span>,alpha=0.5)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">set axis names and labels</span>
ax.set_xlabel(<span style="font-style: italic;">'x'</span>)
ax.set_ylabel(<span style="font-style: italic;">'y'</span>)
ax.set_zlabel(<span style="font-style: italic;">'z'</span>)

ax.set_xlabel(<span style="font-style: italic;">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span style="font-style: italic;">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span style="font-style: italic;">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">strip the figure of unnecessary stuff</span>
<span style="font-weight: bold; font-style: italic;">ax.xaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
<span style="font-weight: bold; font-style: italic;">ax.yaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
<span style="font-weight: bold; font-style: italic;">ax.zaxis.pane.fill</span> = <span style="font-weight: bold; text-decoration: underline;">False</span>
ax.xaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span style="font-style: italic;">'w'</span>)
<span style="font-weight: bold; font-style: italic;">font</span> = {<span style="font-style: italic;">'family'</span> : <span style="font-style: italic;">'sans-serif'</span>,
        <span style="font-style: italic;">'weight'</span> : <span style="font-style: italic;">'normal'</span>,
        <span style="font-style: italic;">'size'</span>   : 20}
plt.rc(<span style="font-style: italic;">'font'</span>, **font)
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span style="font-style: italic;">'off'</span>)
fig.tight_layout(pad=1.0)
<span style="font-weight: bold; font-style: italic;">#</span><span style="font-weight: bold; font-style: italic;">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span style="font-style: italic;">'./img/HRadialeFunktion.png'</span>)
plt.show()


</pre>
</div>


<div id="org98268c0" class="figure">
<p><img src="./img/HRadialeFunktion.png" alt="HRadialeFunktion.png" title="Hankel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 4: </span>Die Funktion die radial die Umlaufrichtung beschreibt</p>
</div>

<p>
Zu einer Funktion mit dem Index \(m\) können mehrere Nullstellen gefunden werden, deren Lage aus Tabellen bekannt ist&#x2026; Mit einem gewählten Radius \(r\) und einer Wellenzahl \(k\) können die Nullstellen für ein System bestimmt werden.
</p>

<p>
Mit den drei Quantenzahlen kann eine Eigenmode in einem Zylinder bestimmt werden. Für die Moden im Inneren des Zylinders ist die Funktion der symmetrischen Lösung gegeben durch:
</p>

\begin{equation}
        \mathbf{E(r)}_{q,l,m} =  J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big) B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big)\exp^{jm\varphi}
\end{equation}

<p>
In den hier vorgestellten Verhältnissen ist \(k_{eff}\) nicht bekannt. Aus der Bedingung, dass das magnetische Feld \(B(r) = -\frac{j}{\omega} \nabla\times E(r)\) an dem Übergang  \(\rho = r\) kontinuierlich ist, ergibt sich das Verhältnis, dass die radiale innere Lösung an diesem Punkt gleich der radialen äußeren Lösung sein muss.
</p>

\begin{equation}\label{eqn:effektiveWellenzahl}
    k_{eff}\frac{[J_{m}(k_{eff}\cdot r)]'}{J_{m}(k_{eff}\cdot r)}   = k_{0} \frac{[H^{1}_{m}(k_{0}\cdot r)]'}{H^{1}_{m}(k_{0}\cdot r)}
\end{equation}

<p>
Die Änderung der Funktion \([J_{m}(k_{eff}\cdot r)]'\) bzw. \([H^{1}_{m}(k_{0}\cdot r)]'\)  kann durch eine Finite-Elementen-Analyse numerisch genähert und gelöst werden. Dadurch kann die effektive Wellenzahl einer Mode gefunden werden.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgde7dc19" class="outline-2">
<h2 id="orgde7dc19">Numerische Approximation</h2>
<div class="outline-text-2" id="text-orgde7dc19">
<p>
Lösungen der Maxwellgleichungen können numerisch approximiert werden. Dabei werden zu untersuchende Strukturen auf einem Rechengitter projiziert. Ein einfaches Rechengitter lässt sich über folgenden Code in C realisieren
</p>
</div>
<div id="outline-container-org7a50d2d" class="outline-3">
<h3 id="org7a50d2d">Codebeispiel:</h3>
<div class="outline-text-3" id="text-org7a50d2d">
<p>
Ich habe den Code in folgendes Repository verlagert: Er beinhaltet momentan verschiedene Matrixtransformationen, die Parallel auf einer Grafikkarte ausgeführt werden können. Im Sinne des Clean Code Prinzips muss dieser noch refaktorisiert werden.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.2 (<a href="https://orgmode.org">Org</a> mode 9.4.4)</p>
</div>
</body>
</html>
