<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arbeitsproben</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Arbeitsproben</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org557fde7">Numerische Berechnungen von Elektro-magnetischen Phänomenen</a></li>
<li><a href="#orgfee7c4e">Die harmonische Störung des dielektrischen Feldes</a>
<ul>
<li><a href="#orgf3aa4b8">Codebeispiel: Die Sinus-Funktion eine Lösung des freien Feldes</a></li>
</ul>
</li>
<li><a href="#org3e5f7ac">Lösung der Wellengleichung in endlichen Geometrien</a>
<ul>
<li><a href="#org083d01f">Potential in einem Zylinder</a></li>
</ul>
</li>
<li><a href="#org5ed2712">Bestimmte Harmonische: Flüstergaleriemoden</a>
<ul>
<li><a href="#org588b49a">Allgemeine Funktion der 3D-Wellengleichung</a></li>
<li><a href="#org28cb66a">Die Azimutale Funktion</a>
<ul>
<li><a href="#org89eb2b9">Codebeispiel: Azimutale Funktion</a></li>
</ul>
</li>
<li><a href="#org3cf597b">Funktion der Z-Koordinate bzw. der Höhe</a>
<ul>
<li><a href="#org72b90ea">Codebeispiel für die vertikale Richtung</a></li>
</ul>
</li>
<li><a href="#orgd0c50cd">Die Radiale Funktion</a>
<ul>
<li><a href="#org93b1224">Codebeispiel der Besselfunktionen</a></li>
<li><a href="#org86583f0">Codebeispiel der radialen Funktion innerhalb des Resonators</a></li>
<li><a href="#org2665f44">Codebeispiel der radialen Funktion außerhalb des Resonators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf3677b8">Numerische Approximation</a>
<ul>
<li><a href="#orgef0beb1">Codebeispiel:</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org557fde7" class="outline-2">
<h2 id="org557fde7">Numerische Berechnungen von Elektro-magnetischen Phänomenen</h2>
<div class="outline-text-2" id="text-org557fde7">
<p>
Auf dieser Site stelle ich vor, wie ein physikalisches Phänomen - nämlich die Lichtausbreitung in dielektrischen, runden Resonatoren
und wie sie mathematisch beschrieben werden kann. Dabei kommen Theorie und Code-Beispiele zum Einsatz. Im Resultat werden Lösungen von
Differentialgleichungen mit einem numerischen Verfahren vorgestellt. <b>Hinweis:</b> momentan ist dieser Code noch in einem anderen Repository[FN:1]
</p>
</div>
</div>
<div id="outline-container-orgfee7c4e" class="outline-2">
<h2 id="orgfee7c4e">Die harmonische Störung des dielektrischen Feldes</h2>
<div class="outline-text-2" id="text-orgfee7c4e">
<p>
Zunächst wird im Zuge auf die Ausbreitung des Lichtes festgelegt, dass nur harmonische Veränderungen des Feldes betrachtet werden. D.h. dass periodische Veränderungen
des Feldes durch Sinus- und Cosinusfunktionen beschrieben werden können. Mathematisch generell "gesprochen" kommen die periodischen Schwinungen aus der Wellengleichung:
</p>

\begin{equation}
     \Delta\mathbf{E} - \frac{1}{c_{m}^{2}}\frac{\partial^{2}E}{\partial t^{2}} = 0
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(\Delta\)</td>
<td class="org-left">Laplace-Operator</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{E}\)</td>
<td class="org-left">Elektrische Feld</td>
</tr>

<tr>
<td class="org-left">\(c_{m}\)</td>
<td class="org-left">Lichtgeschwindigkeit im Medium</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{k}\)</td>
<td class="org-left">Wellenvektor</td>
</tr>

<tr>
<td class="org-left">\(j\)</td>
<td class="org-left">Imaginäre Einheit</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{r}\)</td>
<td class="org-left">Ortsvektor</td>
</tr>

<tr>
<td class="org-left">\(\omega\)</td>
<td class="org-left">Kreisfrequenz: \hspace{.5mm} \(2\pi f\)</td>
</tr>

<tr>
<td class="org-left">\(t\)</td>
<td class="org-left">Zeiteinheit</td>
</tr>
</tbody>
</table>

<p>
Allgemein kann das elektrische <b>Freie Feld</b> über folgenden algebraischen Ausdruck zusammengefasst werden:
</p>
\begin{equation}
    \mathbf{E} (\mathbf{r},t) = E(\mathbf{z},t)
    = E_{0}\exp{j\mathbf{k}\cdot\mathbf{r}-j\omega t}
\end{equation}
</div>
<div id="outline-container-orgf3aa4b8" class="outline-3">
<h3 id="orgf3aa4b8">Codebeispiel: Die Sinus-Funktion eine Lösung des freien Feldes</h3>
<div class="outline-text-3" id="text-orgf3aa4b8">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt



<span class="org-variable-name">x</span>  = np.linspace(0, 20, 100)

<span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1):
    <span class="org-variable-name">y</span> = np.sin(x);
    plt.plot(x,y,label=r<span class="org-string">'$Sin(x)$'</span>)

plt.axhline(0,color=<span class="org-string">'green'</span>, label=<span class="org-string">'_nolegend_'</span>)
plt.grid()
plt.legend()
plt.xlabel(<span class="org-string">'$x$'</span>)
plt.ylabel(<span class="org-string">'${Sin}(x)$'</span>)
plt.title(r<span class="org-string">'Die Harmonische Schwingung - Sinusfunktion $Sin(x)$'</span>)
plt.savefig(<span class="org-string">'img/matplot-fig.png'</span>)
<span class="org-keyword">return</span> <span class="org-string">'img/matplot-fig.png'</span>

</pre>
</div>


<div id="orgab7c091" class="figure">
<p><img src="./img/matplot-fig.png" alt="1DSinus" title="Sinus" align="center" />
</p>
<p><span class="figure-number">Figure 1: </span>Eine 1D-Sinusfunktion</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org3e5f7ac" class="outline-2">
<h2 id="org3e5f7ac">Lösung der Wellengleichung in endlichen Geometrien</h2>
<div class="outline-text-2" id="text-org3e5f7ac">
<p>
Zu Beginn des Textes wurde die Wellengleichung ohne große Einschränkungen gelöst. In realen Systemen ist so eine Lösung ungenau. In einem unendlich großen
Störungsfreien Raum, stellt die 1D-Sinusfunktion eine gültige Lösung dar.
Für endliche Räume müssen weitere Berücksichtigungen getroffen werden. Eine Einfache Geometrie für Resonatoren ist ein Zylinder.
Ein Zylinder hat schon 3-Raumkoordinaten. Um die periodische Störung zu lösen müssen entsprechend dieser Raumkoordinaten Funktionen gefunden werden, die den
Zylinderraum vollständig beschreiben können.
</p>
</div>

<div id="outline-container-org083d01f" class="outline-3">
<h3 id="org083d01f">Potential in einem Zylinder</h3>
<div class="outline-text-3" id="text-org083d01f">
<p>
Da eine Störung eine Veränderung herbeiführt, wird ein Differentialoperator auf eine Größe \(\psi\) angewandt. Dieser beschreibende Veränderungsoperator berücksichtigt
die 3-Raumrichtungen.
</p>

\begin{equation}\label{eqn:ZylinderWelle}
    -\frac{1}{2}\Big[ \frac{1}{\rho} \frac{\partial}{\partial \rho} \Big( \rho \frac{\partial}{\partial \rho} \Big) + \frac{1}{\rho^{2}}\frac{\partial^{2}}{\partial \varphi^{2}} + \frac{\partial^{2}}{\partial z^{2}} \Big] \psi = L\psi
\end{equation}
</div>
</div>
</div>



<div id="outline-container-org5ed2712" class="outline-2">
<h2 id="org5ed2712">Bestimmte Harmonische: Flüstergaleriemoden</h2>
<div class="outline-text-2" id="text-org5ed2712">
<p>
Flüstergaleriemoden sind bestimmte Harmonische Störungen im Raum. Sie sind an der Seitenwand eines Resonators zu verorten.
Ist die Wellenlänge sind bestimmte Größen des System bekannt, dann Eine Wellenzahl - oder auch ein quantisierter Zustand der Harmonischen Störung
bestimmt werden.
</p>
</div>

<div id="outline-container-org588b49a" class="outline-3">
<h3 id="org588b49a">Allgemeine Funktion der 3D-Wellengleichung</h3>
<div class="outline-text-3" id="text-org588b49a">
<p>
Im Besten Fall kann eine Wellenfunktion gefunden werden, die sich aus 3 einzelnen Funktionen entsprechend der Raumkoordinaten zusammensetzt.
Ohne große Überlegung kann die Funktion folgendermaßen geschrieben werden:
</p>

\begin{equation}\label{eqn:ZylinderPotential}
    \psi = R(\rho)Z(z)\Phi(\varphi).
\end{equation}

<p>
In den folgenden Abschnitte werden diese Funktionen einzeln betrachtet.
</p>
</div>
</div>

<div id="outline-container-org28cb66a" class="outline-3">
<h3 id="org28cb66a">Die Azimutale Funktion</h3>
<div class="outline-text-3" id="text-org28cb66a">
<p>
Als erstes lässt sich relativ einfach die azimutale Funktion bestimmen. Die Azimutale Funktion umläuft den Zylinder.
Folgendes Codebeispiel veranschautlicht diese.
</p>
</div>

<div id="outline-container-org89eb2b9" class="outline-4">
<h4 id="org89eb2b9">Codebeispiel: Azimutale Funktion</h4>
<div class="outline-text-4" id="text-org89eb2b9">
<div class="org-src-container">
<pre class="src src-python">

<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d
<span class="org-keyword">import</span> mpl_toolkits.mplot3d.art3d <span class="org-keyword">as</span> art3d
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> Circle
<span class="org-keyword">from</span> matplotlib <span class="org-keyword">import</span> pyplot <span class="org-keyword">as</span> plt

<span class="org-comment-delimiter">#</span><span class="org-comment">Define a class for the coordinate-system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_verts3d</span> = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        xs3d, ys3d, zs3d = <span class="org-keyword">self</span>._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">This Function will draw a cylinder</span>
<span class="org-keyword">def</span> <span class="org-function-name">plot_3D_cylinder</span>(radius, height, elevation=0, resolution=100, color=<span class="org-string">'b'</span>, x_center = 0, y_center = 0):

    <span class="org-comment-delimiter">#</span><span class="org-comment">init where to draw the projections</span>
    fig=plt.figure(figsize=(5,5))
    ax = Axes3D(fig, azim=45, elev=21)

    <span class="org-comment-delimiter">#</span><span class="org-comment">take values from the function input</span>
    x = np.linspace(x_center-radius, x_center+radius, resolution)
    z = np.linspace(elevation, elevation+height, resolution)
    X, Z = np.meshgrid(x, z)

    theta = np.linspace(-1 * np.pi, 1 * np.pi, 1000)

    <span class="org-comment-delimiter">#</span><span class="org-comment">coordinate conversion cartesain x_,y_,z_ in cylindrical</span>
    R = 1
    x_ = radius * np.cos(theta)+x_center
    y_ = radius *np.sin(theta)+y_center
    z_ = np.sin(18*theta)
    Y = np.sqrt(radius**2 - (X - x_center)**2) + y_center <span class="org-comment-delimiter"># </span><span class="org-comment">Pythagorean theorem</span>


    <span class="org-comment-delimiter">#</span><span class="org-comment">Color the cylinder surface-patches</span>
    ax.plot_surface(X, Y, Z,alpha=0.3, linewidth=0, color=<span class="org-string">'deepskyblue'</span>)
    ax.plot_surface(X, (2*y_center-Y), Z,alpha=0.2, linewidth=0, color=<span class="org-string">'lightskyblue'</span>)
    floor = Circle((x_center, y_center), radius, color=<span class="org-string">'deepskyblue'</span>,alpha=0.3)
    ax.add_patch(floor)
    art3d.pathpatch_2d_to_3d(floor, z=elevation, zdir=<span class="org-string">"z"</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Color the circle-surfaces</span>
    ceiling = Circle((x_center, y_center), radius, color=<span class="org-string">'deepskyblue'</span>,alpha=0.5)
    ax.add_patch(ceiling)
    art3d.pathpatch_2d_to_3d(ceiling, z=elevation+height, zdir=<span class="org-string">"z"</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Plot the encircling function</span>
    ax.plot(x_, y_, z_, color = <span class="org-string">'fuchsia'</span>)

    arrow_prop_dict = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add an arrow that outlines the function's path</span>
    a = Arrow3D([0, 79], [0, 15], [0, 2.8], **arrow_prop_dict, color=<span class="org-string">'darkorchid'</span>, linestyle=<span class="org-string">"dashed"</span>,linewidth=3.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a red orthogonal arrow in the \rho respectively y-direction</span>
    a = Arrow3D([0, 0], [0, 75], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the y-cartesain coordinate</span>
    a = Arrow3D([0, 0], [0, 95], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the x-cartesain coordinate</span>
    a = Arrow3D([0, 95], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the z-direction</span>
    a = Arrow3D([0, 0], [0, 0], [0, 6.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a blue arrow indicating the z-direction</span>
    a = Arrow3D([0, 0], [0, 0], [0, 6], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">add letters for orientation o-origin, \rho etc. ...</span>
    ax.text(3, 0.0, -.35, r<span class="org-string">'$o$'</span>)
    ax.text(0, 75, 0, r<span class="org-string">'$\rho$'</span>)
    ax.text(60, 60, 0, r<span class="org-string">'$\varphi$'</span>)
    ax.text(0, -2, 7, r<span class="org-string">'$z$'</span>)
    ax.text(107, 15, 3.4, r<span class="org-string">'$\psi(\rho,z,\varphi)$'</span>)
    ax.text(100, 0, 0, r<span class="org-string">'$x$'</span>)
    ax.text(0, 98, 0, r<span class="org-string">'$y$'</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Now draw the \varphi-axis *hint: it's angle dependent 'cause it's a cylinder</span>
    thetaAng = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>
    rAng =  50.0 <span class="org-comment-delimiter">#</span><span class="org-comment">circle radius</span>
    x1 = rAng * np.cos(thetaAng) + 0
    x2 = rAng * np.sin(thetaAng) + 0

    <span class="org-comment-delimiter">#</span><span class="org-comment">Plot this axis as a function and make it green</span>
    ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)

    <span class="org-comment-delimiter">#</span><span class="org-comment">name the axis</span>
    ax.set_xlabel(<span class="org-string">'x-Achse'</span>, fontsize=16)
    ax.set_ylabel(<span class="org-string">'y-Achse'</span>, fontsize=16)
    ax.set_zlabel(<span class="org-string">'z-Achse'</span>, fontsize=16)


    <span class="org-comment-delimiter">#</span><span class="org-comment">set a limit on the z-axis/**sorry it's messy &lt;2023-03-02 Thu&gt; shoshin</span>
    ax.set_zlim(-4,4)

    <span class="org-comment-delimiter">#</span><span class="org-comment">clean the canvas no grid whatsoever or other oob stuff</span>
    ax.xaxis.pane.fill = <span class="org-constant">False</span>
    ax.yaxis.pane.fill = <span class="org-constant">False</span>
    ax.zaxis.pane.fill = <span class="org-constant">False</span>
    ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
    ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
    ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)

    ax.grid(<span class="org-constant">False</span>)
    font = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
    plt.rc(<span class="org-string">'font'</span>, **font)
    <span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Zylindrische Kavit&#228;t", fontsize=25)</span>
    plt.axis(<span class="org-string">'off'</span>)
    <span class="org-comment-delimiter">#</span><span class="org-comment">fig.savefig('ZylinderSystem.png', dpi=320)</span>
    plt.show()

<span class="org-comment-delimiter">#</span><span class="org-comment">create a figure for plotting</span>
fig = plt.figure()

<span class="org-comment-delimiter">#</span><span class="org-comment">create a 3d ax-element</span>
ax = fig.add_subplot(111, projection=<span class="org-string">'3d'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">adjust view on the art-piece</span>
ax.view_init(azim=-90, elev=90)
ax.set_axis_off()
plt.show()


<span class="org-comment-delimiter"># </span><span class="org-comment">Write parameters to be passed to above cylinder function</span>
radius = 50
height = 2
elevation = -1
resolution = 100
color = <span class="org-string">'lightskyblue'</span>
x_center = 0
y_center = 0

<span class="org-comment-delimiter"># </span><span class="org-comment">pass the parameter</span>
plot_3D_cylinder(radius, height, elevation=elevation, resolution=resolution, color=color, x_center=x_center, y_center=y_center)

<span class="org-comment-delimiter">#</span><span class="org-comment">save the figure</span>
plt.savefig(<span class="org-string">'img/matplot-azimuthal.png'</span>)
<span class="org-comment-delimiter">#</span><span class="org-comment">return 'img/matplot-azimuthal.png'</span>


</pre>
</div>


<div id="orgc7db58c" class="figure">
<p><img src="./img/matplot-azimuthal.png" alt="matplot-azimuthal.png" title="AzimutaleFunktion" align="center" />
</p>
<p><span class="figure-number">Figure 2: </span>Die azimutale Funktion beschreibt die Umlaufrichtung</p>
</div>

\begin{equation}\label{eqn:azimuthal-Zahl}
  m = \frac{2\pi r n_{m}}{\lambda_{0}}
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(m\)</td>
<td class="org-left">Azimutale Quantenzahl</td>
</tr>

<tr>
<td class="org-left">\(r\)</td>
<td class="org-left">Radius</td>
</tr>

<tr>
<td class="org-left">\(n_{m}\)</td>
<td class="org-left">Brechungsindex</td>
</tr>
</tbody>
</table>

<p>
Der mathematische Ausdruck ist im Vergleich zum oberen Codebeispiel ziemlich unspektakulär:
</p>
\begin{equation}
     \Phi(\varphi) = e^{(jm \varphi)}
\end{equation}
</div>
</div>
</div>

<div id="outline-container-org3cf597b" class="outline-3">
<h3 id="org3cf597b">Funktion der Z-Koordinate bzw. der Höhe</h3>
<div class="outline-text-3" id="text-org3cf597b">
<p>
Für die Funktion \(Z(z)\) ergeben sich unterschiedliche Funktionen. Symmetrische, auch als unsymmetrische  Funktionen.
Das Liegt daran, dass sowohl Cosinus als auch Sinus zulässig sind.
</p>


\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
       A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big),   & \text{für } z < - \bigg(\frac{h}{2}\bigg) .\\
       B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big), & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
       A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg)
        \end{array}\right.
\end{equation}

<p>
und unsymmetrischen Lösungen:
</p>

\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
        A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z \Big),   & \text{für } z < -\bigg(\frac{h}{2}\bigg) .\\
        B sin\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big) , & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
        - A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg).
        \end{array}\right.
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="Wellenzahlen" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(k_{eff}\)</td>
<td class="org-left">effektive Wellenzahl einer Mode</td>
</tr>

<tr>
<td class="org-left">\(k_{i}\)</td>
<td class="org-left">Wellenzahl im Festkörper</td>
</tr>

<tr>
<td class="org-left">\(k_{0}\)</td>
<td class="org-left">Wellenzahl im Vakuum</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">Höhe eines Resonators</td>
</tr>
</tbody>
</table>

<p>
Die Höhe \(h\) gibt die Randbedingung für die Gültigkeit der Sinus/Cosinus Funktion für die $Z$-Koordinate wieder. Jenseits einer gegebenen Höhe sind andere Funktionen definiert, die mit zunehmendem/abnehmenden \(z\) exponential abfallen und gegen \(0\) gehen.
</p>
</div>

<div id="outline-container-org72b90ea" class="outline-4">
<h4 id="org72b90ea">Codebeispiel für die vertikale Richtung</h4>
</div>
</div>

<div id="outline-container-orgd0c50cd" class="outline-3">
<h3 id="orgd0c50cd">Die Radiale Funktion</h3>
<div class="outline-text-3" id="text-orgd0c50cd">
<p>
Für die radiale Funktion \(R(\rho)\) ergibt sich durch die Separation der Variablen Bessels-Differentialgleichung.
</p>

\begin{equation}\label{eqn:PreBessel}
    \rho^{2}\Big( \frac{d^{2}R}{d \rho^{2}}\Big) + (\rho^{2}k^{2}-m^{2})R = 0
\end{equation}

<p>
Durch die Substitution \(\mathbf{k \rho = x}\) ist der Ausdruck aus Gleichung als die allgemeine Form darstellbar.
</p>

\begin{equation}
    x^{2}\frac{d^{2}R}{dx^{2}}+\frac{dR}{dx}+(x^{2}-m^{2})R = 0
\end{equation}

<p>
Diese Differentialgleichung kann durch Besselfunktionen und Hankelfunktionen erster Gattung gelöst werden. Das Innere des Resonators wird dabei durch Besselfunktionen beschrieben.
</p>
\begin{equation}
   R(\rho) = J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big), \hspace{0.5cm} \rho < r
\end{equation}
</div>


<div id="outline-container-org93b1224" class="outline-4">
<h4 id="org93b1224">Codebeispiel der Besselfunktionen</h4>
<div class="outline-text-4" id="text-org93b1224">
<p>
Im Folgenden wird in Python ein Codebeispiel gezeigt, in welchem das Innere eines Resonators dargestellt wird. Es veranschaulicht eine radiale Veränderung des Elektromagnetischen Feldes.
</p>
</div>
</div>

<div id="outline-container-org86583f0" class="outline-4">
<h4 id="org86583f0">Codebeispiel der radialen Funktion innerhalb des Resonators</h4>
<div class="outline-text-4" id="text-org86583f0">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib
<span class="org-keyword">from</span> scipy.special <span class="org-keyword">import</span> hankel1e, y1_zeros
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d

<span class="org-comment-delimiter">#</span><span class="org-comment">needed for 3D-coordinate system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_verts3d</span> = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        xs3d, ys3d, zs3d = <span class="org-keyword">self</span>._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">using circular coordinates again! range of theta-axis is needed</span>
thetaAng = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">assume the edge of the resonator to be rAng = 50</span>
rAng =  50.0
x1 = rAng * np.cos(thetaAng) + 0
x2 = rAng * np.sin(thetaAng) + 0

<span class="org-comment-delimiter">#</span><span class="org-comment">prepare the canvas and axis for the function</span>
fig=plt.figure(figsize=(5,5))
ax = Axes3D(fig, azim=45, elev=21)

<span class="org-comment-delimiter">#</span><span class="org-comment">create coordinate arrows for cylindrical and cartesian directions</span>
arrow_prop_dict = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)
a = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)


<span class="org-comment-delimiter">#</span><span class="org-comment">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span class="org-string">'$o$'</span>)
ax.text(0, 55, 0, r<span class="org-string">'$\rho$'</span>)
ax.text(45, 45, 0, r<span class="org-string">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span class="org-string">'$z$'</span>)
ax.text(75, 0, 0, r<span class="org-string">'$x$'</span>)
ax.text(0, 70, 0, r<span class="org-string">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span class="org-string">'$R(\rho)$'</span>)


<span class="org-comment-delimiter">#</span><span class="org-comment">create the bessel-function</span>
<span class="org-keyword">def</span> <span class="org-function-name">drumhead_height</span>(n, k, distance, angle, t):

   kth_zero = sp.jn_zeros(n, k)[-1]

   <span class="org-keyword">return</span> np.cos(t) * np.cos(n*angle) * sp.jn(n, distance*kth_zero)

<span class="org-comment-delimiter">#</span><span class="org-comment">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
theta = np.r_[0:2*np.pi:50j]
radius = np.r_[0:50:50j]

<span class="org-comment-delimiter">#</span><span class="org-comment">transform cartesian coordinates into cylindrical ones</span>
x = np.array([r * np.cos(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
y = np.array([r * np.sin(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
z = np.array([drumhead_height(0,2, r, theta,1) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])


<span class="org-comment-delimiter">#</span><span class="org-comment">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span class="org-string">'jet'</span>,alpha=0.5)

<span class="org-comment-delimiter">#</span><span class="org-comment">set axis names and labels</span>
ax.set_xlabel(<span class="org-string">'x'</span>)
ax.set_ylabel(<span class="org-string">'y'</span>)
ax.set_zlabel(<span class="org-string">'z'</span>)

ax.set_xlabel(<span class="org-string">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span class="org-comment-delimiter">#</span><span class="org-comment">strip the figure of unnecessary stuff</span>
ax.xaxis.pane.fill = <span class="org-constant">False</span>
ax.yaxis.pane.fill = <span class="org-constant">False</span>
ax.zaxis.pane.fill = <span class="org-constant">False</span>
ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
font = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
plt.rc(<span class="org-string">'font'</span>, **font)
<span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span class="org-string">'off'</span>)
fig.tight_layout(pad=1.0)
<span class="org-comment-delimiter">#</span><span class="org-comment">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span class="org-string">'./img/BRadialeFunktion.png'</span>)
plt.show()



</pre>
</div>


<div id="org882767b" class="figure">
<p><img src="./img/BRadialeFunktion.png" alt="BRadialeFunktion.png" title="Bessel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 3: </span>Die Funktion die radial die Umlaufrichtung beschreibt</p>
</div>
</div>
</div>


<div id="outline-container-org2665f44" class="outline-4">
<h4 id="org2665f44">Codebeispiel der radialen Funktion außerhalb des Resonators</h4>
<div class="outline-text-4" id="text-org2665f44">
<p>
Außerhalb der endlichen Geometrie des Resonator fallen die Ausprägungen des elektromagntischen Feldes stark ab. Durch Hankelfunktionen wird diesem Umstand mathematisch
Rechung getragen.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib
<span class="org-keyword">from</span> scipy.special <span class="org-keyword">import</span> hankel1e, y1_zeros
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d

<span class="org-comment-delimiter">#</span><span class="org-comment">needed for 3D-coordinate system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_verts3d</span> = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        xs3d, ys3d, zs3d = <span class="org-keyword">self</span>._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">using circular coordinates again! range of theta-axis is needed</span>
thetaAng = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">assume the edge of the resonator to be rAng = 50</span>
rAng =  50.0
x1 = rAng * np.cos(thetaAng) + 0
x2 = rAng * np.sin(thetaAng) + 0

<span class="org-comment-delimiter">#</span><span class="org-comment">prepare the canvas and axis for the function</span>
fig=plt.figure(figsize=(5,5))
ax = Axes3D(fig, azim=45, elev=21)

<span class="org-comment-delimiter">#</span><span class="org-comment">create coordinate arrows for cylindrical and cartesian directions</span>
arrow_prop_dict = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)

a = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)

<span class="org-comment-delimiter">#</span><span class="org-comment">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span class="org-string">'$o$'</span>)
ax.text(0, 55, 0, r<span class="org-string">'$\rho$'</span>)
ax.text(45, 45, 0, r<span class="org-string">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span class="org-string">'$z$'</span>)
ax.text(75, 0, 0, r<span class="org-string">'$x$'</span>)
ax.text(0, 70, 0, r<span class="org-string">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span class="org-string">'$R(\rho)$'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the hankel-function</span>
<span class="org-keyword">def</span> <span class="org-function-name">drumhead_height</span>(n, k, distance, angle, t):

   kth_zero = sp.jn_zeros(n, k)[-1]

   <span class="org-keyword">return</span> np.cos(t) * np.cos(n*angle) * sp.hankel1e(n, distance*kth_zero)

<span class="org-comment-delimiter">#</span><span class="org-comment">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
theta = np.r_[0:2*np.pi:50j]
radius = np.r_[55:75:50j]

<span class="org-comment-delimiter">#</span><span class="org-comment">transform cartesian coordinates into cylindrical ones</span>
x = np.array([r * np.cos(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
y = np.array([r * np.sin(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
z = np.array([drumhead_height(0,2, r, theta,1) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])

<span class="org-comment-delimiter">#</span><span class="org-comment">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span class="org-string">'jet'</span>,alpha=0.5)

<span class="org-comment-delimiter">#</span><span class="org-comment">set axis names and labels</span>
ax.set_xlabel(<span class="org-string">'x'</span>)
ax.set_ylabel(<span class="org-string">'y'</span>)
ax.set_zlabel(<span class="org-string">'z'</span>)

ax.set_xlabel(<span class="org-string">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span class="org-comment-delimiter">#</span><span class="org-comment">strip the figure of unnecessary stuff</span>
ax.xaxis.pane.fill = <span class="org-constant">False</span>
ax.yaxis.pane.fill = <span class="org-constant">False</span>
ax.zaxis.pane.fill = <span class="org-constant">False</span>
ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
font = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
plt.rc(<span class="org-string">'font'</span>, **font)
<span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span class="org-string">'off'</span>)
fig.tight_layout(pad=1.0)
<span class="org-comment-delimiter">#</span><span class="org-comment">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span class="org-string">'./img/HRadialeFunktion.png'</span>)
plt.show()


</pre>
</div>


<div id="orgd0bdca4" class="figure">
<p><img src="./img/HRadialeFunktion.png" alt="HRadialeFunktion.png" title="Hankel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 4: </span>Die Funktion die radial die Umlaufrichtung beschreibt</p>
</div>

<p>
Zu einer Funktion mit dem Index \(m\) können mehrere Nullstellen gefunden werden, deren Lage aus Tabellen bekannt ist&#x2026; Mit einem gewählten Radius \(r\) und einer Wellenzahl \(k\) können die Nullstellen für ein System bestimmt werden.
</p>

<p>
Mit den drei Quantenzahlen kann eine Eigenmode in einem Zylinder bestimmt werden. Für die Moden im Inneren des Zylinders ist die Funktion der symmetrischen Lösung gegeben durch:
</p>

\begin{equation}
        \mathbf{E(r)}_{q,l,m} =  J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big) B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big)\exp^{jm\varphi}
\end{equation}

<p>
In den hier vorgestellten Verhältnissen ist \(k_{eff}\) nicht bekannt. Aus der Bedingung, dass das magnetische Feld \(B(r) = -\frac{j}{\omega} \nabla\times E(r)\) an dem Übergang  \(\rho = r\) kontinuierlich ist, ergibt sich das Verhältnis, dass die radiale innere Lösung an diesem Punkt gleich der radialen äußeren Lösung sein muss.
</p>

\begin{equation}\label{eqn:effektiveWellenzahl}
    k_{eff}\frac{[J_{m}(k_{eff}\cdot r)]'}{J_{m}(k_{eff}\cdot r)}   = k_{0} \frac{[H^{1}_{m}(k_{0}\cdot r)]'}{H^{1}_{m}(k_{0}\cdot r)}
\end{equation}

<p>
Die Änderung der Funktion \([J_{m}(k_{eff}\cdot r)]'\) bzw. \([H^{1}_{m}(k_{0}\cdot r)]'\)  kann durch eine Finite-Elementen-Analyse numerisch genähert und gelöst werden. Dadurch kann die effektive Wellenzahl einer Mode gefunden werden.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-orgf3677b8" class="outline-2">
<h2 id="orgf3677b8">Numerische Approximation</h2>
<div class="outline-text-2" id="text-orgf3677b8">
<p>
Lösungen der Maxwellgleichungen können numerisch approximiert werden. Dabei werden zu untersuchende Strukturen auf einem Rechengitter projiziert. Ein einfaches Rechengitter lässt sich über folgenden Code in C realisieren
</p>
</div>
<div id="outline-container-orgef0beb1" class="outline-3">
<h3 id="orgef0beb1">Codebeispiel:</h3>
<div class="outline-text-3" id="text-orgef0beb1">
<p>
Ich habe den Code in folgendes Repository verlagert: [FN:1] <a href="https://github.com/shosh1n/EMCuda">EM-Cuda</a>. Er beinhaltet momentan verschiedene Matrixtransformationen, die Parallel auf einer Grafikkarte ausgeführt werden können. Im Sinne des Clean Code Prinzips muss dieser noch refaktorisiert werden.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.5.5)</p>
</div>
</body>
</html>
