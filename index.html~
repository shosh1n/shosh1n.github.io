<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Arbeitsproben</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Arbeitsproben</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9536a50">Numerische Berechnungen von Elektro-magnetischen Phänomenen</a></li>
<li><a href="#orgd2e87bd">Die harmonische Störung des dielektrischen Feldes</a>
<ul>
<li><a href="#org1dbf1ce">Codebeispiel: Die Sinus-Funktion eine Lösung des freien Feldes</a></li>
</ul>
</li>
<li><a href="#org34901cf">Lösung der Wellengleichung in endlichen Geometrien</a>
<ul>
<li><a href="#org1ce1e0e">Potential in einem Zylinder</a></li>
</ul>
</li>
<li><a href="#org206c7e0">Bestimmte Harmonische: Flüstergaleriemoden</a>
<ul>
<li><a href="#org4cb9db8">Allgemeine Funktion der 3D-Wellengleichung</a></li>
<li><a href="#org0d9790d">Die Azimutale Funktion</a>
<ul>
<li><a href="#org3ce196c">Codebeispiel: Azimutale Funktion</a></li>
</ul>
</li>
<li><a href="#org59fd68c">Funktion der Z-Koordinate bzw. der Höhe</a>
<ul>
<li><a href="#org70a0a5e">Codebeispiel für die vertikale Richtung</a></li>
</ul>
</li>
<li><a href="#org368d7c7">Die Radiale Funktion</a>
<ul>
<li><a href="#org09b6ac1">Codebeispiel der Besselfunktionen</a></li>
<li><a href="#org3dfdebd">Codebeispiel der radialen Funktion innerhalb des Resonators</a></li>
<li><a href="#orgd1b83a9">Codebeispiel der radialen Funktion außerhalb des Resonators</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org0d90540">Numerische Approximation</a>
<ul>
<li><a href="#org0d4713e">Codebeispiel: ACHTUNG DIESER CODE WIRD NOCH VERLAGERT ER IST ZUVIEL ;)</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-org9536a50" class="outline-2">
<h2 id="org9536a50">Numerische Berechnungen von Elektro-magnetischen Phänomenen</h2>
<div class="outline-text-2" id="text-org9536a50">
<p>
Auf dieser Site stelle ich vor, wie ein physikalisches Phänomen - nämlich die Lichtausbreitung in dielektrischen, runden Resonatoren
mathematisch beschrieben werden kann. Dabei kommen Theorie und Code-Beispiele zum Einsatz. Im Resultat werden Lösungen von
Differentialgleichungen mit einem numerischen Verfahren vorgestellt.
</p>
</div>
</div>

<div id="outline-container-orgd2e87bd" class="outline-2">
<h2 id="orgd2e87bd">Die harmonische Störung des dielektrischen Feldes</h2>
<div class="outline-text-2" id="text-orgd2e87bd">
<p>
Zunächst wird im Zuge auf die Ausbreitung des Lichtes festgelegt, dass nur harmonische Veränderungen des Feldes betrachtet werden. D.h. dass periodische Veränderungen
des Feldes durch Sinus- und Cosinusfunktionen beschrieben werden können. Mathematisch generell "gesprochen" kommen die periodischen Schwinungen aus der Wellengleichung:
</p>

\begin{equation}
     \Delta\mathbf{E} - \frac{1}{c_{m}^{2}}\frac{\partial^{2}E}{\partial t^{2}} = 0
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(\Delta\)</td>
<td class="org-left">Laplace-Operator</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{E}\)</td>
<td class="org-left">Elektrische Feld</td>
</tr>

<tr>
<td class="org-left">\(c_{m}\)</td>
<td class="org-left">Lichtgeschwindigkeit im Medium</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{k}\)</td>
<td class="org-left">Wellenvektor</td>
</tr>

<tr>
<td class="org-left">\(j\)</td>
<td class="org-left">Imaginäre Einheit</td>
</tr>

<tr>
<td class="org-left">\(\mathbf{r}\)</td>
<td class="org-left">Ortsvektor</td>
</tr>

<tr>
<td class="org-left">\(\omega\)</td>
<td class="org-left">Kreisfrequenz: \hspace{.5mm} \(2\pi f\)</td>
</tr>

<tr>
<td class="org-left">\(t\)</td>
<td class="org-left">Zeiteinheit</td>
</tr>
</tbody>
</table>

<p>
Allgemein kann das elektrische <b>Freie Feld</b> über folgenden algebraischen Ausdruck zusammengefasst werden:
</p>
\begin{equation}
    \mathbf{E} (\mathbf{r},t) = E(\mathbf{z},t)
    = E_{0}\exp{j\mathbf{k}\cdot\mathbf{r}-j\omega t}
\end{equation}
</div>
<div id="outline-container-org1dbf1ce" class="outline-3">
<h3 id="org1dbf1ce">Codebeispiel: Die Sinus-Funktion eine Lösung des freien Feldes</h3>
<div class="outline-text-3" id="text-org1dbf1ce">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt



<span class="org-variable-name">x</span>  = np.linspace(0, 20, 100)

<span class="org-keyword">for</span> n <span class="org-keyword">in</span> <span class="org-builtin">range</span>(1):
    <span class="org-variable-name">y</span> = np.sin(x);
    plt.plot(x,y,label=r<span class="org-string">'$Sin(x)$'</span>)

plt.axhline(0,color=<span class="org-string">'green'</span>, label=<span class="org-string">'_nolegend_'</span>)
plt.grid()
plt.legend()
plt.xlabel(<span class="org-string">'$x$'</span>)
plt.ylabel(<span class="org-string">'${Sin}(x)$'</span>)
plt.title(r<span class="org-string">'Die Harmonische Schwingung - Sinusfunktion $Sin(x)$'</span>)
plt.savefig(<span class="org-string">'img/matplot-fig.png'</span>)
<span class="org-keyword">return</span> <span class="org-string">'img/matplot-fig.png'</span>

</pre>
</div>


<div id="org9043948" class="figure">
<p><img src="./img/matplot-fig.png" alt="1DSinus" title="Sinus" align="center" />
</p>
<p><span class="figure-number">Figure 1: </span>Eine 1D-Sinusfunktion</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org34901cf" class="outline-2">
<h2 id="org34901cf">Lösung der Wellengleichung in endlichen Geometrien</h2>
<div class="outline-text-2" id="text-org34901cf">
<p>
Zu Beginn des Textes wurde die Wellengleichung ohne große Einschränkungen gelöst. In realen Systemen ist so eine Lösung ungenau. In einem unendlich großen
Störungsfreien Raum, stellt die 1D-Sinusfunktion eine gültige Lösung dar.
Für endliche Räume müssen weitere Berücksichtigungen getroffen werden. Eine Einfache Geometrie für Resonatoren ist ein Zylinder.
Ein Zylinder hat schon 3-Raumkoordinaten. Um die periodische Störung zu lösen müssen entsprechend dieser Raumkoordinaten Funktionen gefunden werden, die den
Zylinderraum vollständig beschreiben können.
</p>
</div>

<div id="outline-container-org1ce1e0e" class="outline-3">
<h3 id="org1ce1e0e">Potential in einem Zylinder</h3>
<div class="outline-text-3" id="text-org1ce1e0e">
<p>
Da eine Störung eine Veränderung herbeiführt, wird ein Differentialoperator auf eine Größe \(\psi\) angewandt. Dieser beschreibende Veränderungsoperator berücksichtigt
die 3-Raumrichtungen.
</p>

\begin{equation}\label{eqn:ZylinderWelle}
    -\frac{1}{2}\Big[ \frac{1}{\rho} \frac{\partial}{\partial \rho} \Big( \rho \frac{\partial}{\partial \rho} \Big) + \frac{1}{\rho^{2}}\frac{\partial^{2}}{\partial \varphi^{2}} + \frac{\partial^{2}}{\partial z^{2}} \Big] \psi = L\psi
\end{equation}
</div>
</div>
</div>



<div id="outline-container-org206c7e0" class="outline-2">
<h2 id="org206c7e0">Bestimmte Harmonische: Flüstergaleriemoden</h2>
<div class="outline-text-2" id="text-org206c7e0">
<p>
Flüstergaleriemoden sind bestimmte Harmonische Störungen im Raum. Sie sind an der Seitenwand eines Resonators zu verorten.
Ist die Wellenlänge sind bestimmte Größen des System bekannt, dann Eine Wellenzahl - oder auch ein quantisierter Zustand der Harmonischen Störung
bestimmt werden.
</p>
</div>

<div id="outline-container-org4cb9db8" class="outline-3">
<h3 id="org4cb9db8">Allgemeine Funktion der 3D-Wellengleichung</h3>
<div class="outline-text-3" id="text-org4cb9db8">
<p>
Im Besten Fall kann eine Wellenfunktion gefunden werden, die sich aus 3 einzelnen Funktionen entsprechend der Raumkoordinaten zusammensetzt.
Ohne große Überlegung kann die Funktion folgendermaßen geschrieben werden:
</p>

\begin{equation}\label{eqn:ZylinderPotential}
    \psi = R(\rho)Z(z)\Phi(\varphi).
\end{equation}

<p>
In den folgenden Abschnitte werden diese Funktionen einzeln betrachtet.
</p>
</div>
</div>

<div id="outline-container-org0d9790d" class="outline-3">
<h3 id="org0d9790d">Die Azimutale Funktion</h3>
<div class="outline-text-3" id="text-org0d9790d">
<p>
Als erstes lässt sich relativ einfach die azimutale Funktion bestimmen. Die Azimutale Funktion umläuft den Zylinder.
Folgendes Codebeispiel veranschautlicht diese.
</p>
</div>

<div id="outline-container-org3ce196c" class="outline-4">
<h4 id="org3ce196c">Codebeispiel: Azimutale Funktion</h4>
<div class="outline-text-4" id="text-org3ce196c">
<div class="org-src-container">
<pre class="src src-python">

<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> matplotlib
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d
<span class="org-keyword">import</span> mpl_toolkits.mplot3d.art3d <span class="org-keyword">as</span> art3d
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> Circle
<span class="org-keyword">from</span> matplotlib <span class="org-keyword">import</span> pyplot <span class="org-keyword">as</span> plt

<span class="org-comment-delimiter">#</span><span class="org-comment">Define a class for the coordinate-system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_verts3d</span> = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        xs3d, ys3d, zs3d = <span class="org-keyword">self</span>._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">This Function will draw a cylinder</span>
<span class="org-keyword">def</span> <span class="org-function-name">plot_3D_cylinder</span>(radius, height, elevation=0, resolution=100, color=<span class="org-string">'b'</span>, x_center = 0, y_center = 0):

    <span class="org-comment-delimiter">#</span><span class="org-comment">init where to draw the projections</span>
    fig=plt.figure(figsize=(5,5))
    ax = Axes3D(fig, azim=45, elev=21)

    <span class="org-comment-delimiter">#</span><span class="org-comment">take values from the function input</span>
    x = np.linspace(x_center-radius, x_center+radius, resolution)
    z = np.linspace(elevation, elevation+height, resolution)
    X, Z = np.meshgrid(x, z)

    theta = np.linspace(-1 * np.pi, 1 * np.pi, 1000)

    <span class="org-comment-delimiter">#</span><span class="org-comment">coordinate conversion cartesain x_,y_,z_ in cylindrical</span>
    R = 1
    x_ = radius * np.cos(theta)+x_center
    y_ = radius *np.sin(theta)+y_center
    z_ = np.sin(18*theta)
    Y = np.sqrt(radius**2 - (X - x_center)**2) + y_center <span class="org-comment-delimiter"># </span><span class="org-comment">Pythagorean theorem</span>


    <span class="org-comment-delimiter">#</span><span class="org-comment">Color the cylinder surface-patches</span>
    ax.plot_surface(X, Y, Z,alpha=0.3, linewidth=0, color=<span class="org-string">'deepskyblue'</span>)
    ax.plot_surface(X, (2*y_center-Y), Z,alpha=0.2, linewidth=0, color=<span class="org-string">'lightskyblue'</span>)
    floor = Circle((x_center, y_center), radius, color=<span class="org-string">'deepskyblue'</span>,alpha=0.3)
    ax.add_patch(floor)
    art3d.pathpatch_2d_to_3d(floor, z=elevation, zdir=<span class="org-string">"z"</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Color the circle-surfaces</span>
    ceiling = Circle((x_center, y_center), radius, color=<span class="org-string">'deepskyblue'</span>,alpha=0.5)
    ax.add_patch(ceiling)
    art3d.pathpatch_2d_to_3d(ceiling, z=elevation+height, zdir=<span class="org-string">"z"</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Plot the encircling function</span>
    ax.plot(x_, y_, z_, color = <span class="org-string">'fuchsia'</span>)

    arrow_prop_dict = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add an arrow that outlines the function's path</span>
    a = Arrow3D([0, 79], [0, 15], [0, 2.8], **arrow_prop_dict, color=<span class="org-string">'darkorchid'</span>, linestyle=<span class="org-string">"dashed"</span>,linewidth=3.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a red orthogonal arrow in the \rho respectively y-direction</span>
    a = Arrow3D([0, 0], [0, 75], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the y-cartesain coordinate</span>
    a = Arrow3D([0, 0], [0, 95], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the x-cartesain coordinate</span>
    a = Arrow3D([0, 95], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a black arrow indicating the z-direction</span>
    a = Arrow3D([0, 0], [0, 0], [0, 6.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Add a blue arrow indicating the z-direction</span>
    a = Arrow3D([0, 0], [0, 0], [0, 6], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
    ax.add_artist(a)

    <span class="org-comment-delimiter">#</span><span class="org-comment">add letters for orientation o-origin, \rho etc. ...</span>
    ax.text(3, 0.0, -.35, r<span class="org-string">'$o$'</span>)
    ax.text(0, 75, 0, r<span class="org-string">'$\rho$'</span>)
    ax.text(60, 60, 0, r<span class="org-string">'$\varphi$'</span>)
    ax.text(0, -2, 7, r<span class="org-string">'$z$'</span>)
    ax.text(107, 15, 3.4, r<span class="org-string">'$\psi(\rho,z,\varphi)$'</span>)
    ax.text(100, 0, 0, r<span class="org-string">'$x$'</span>)
    ax.text(0, 98, 0, r<span class="org-string">'$y$'</span>)

    <span class="org-comment-delimiter">#</span><span class="org-comment">Now draw the \varphi-axis *hint: it's angle dependent 'cause it's a cylinder</span>
    thetaAng = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>
    rAng =  50.0 <span class="org-comment-delimiter">#</span><span class="org-comment">circle radius</span>
    x1 = rAng * np.cos(thetaAng) + 0
    x2 = rAng * np.sin(thetaAng) + 0

    <span class="org-comment-delimiter">#</span><span class="org-comment">Plot this axis as a function and make it green</span>
    ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)

    <span class="org-comment-delimiter">#</span><span class="org-comment">name the axis</span>
    ax.set_xlabel(<span class="org-string">'x-Achse'</span>, fontsize=16)
    ax.set_ylabel(<span class="org-string">'y-Achse'</span>, fontsize=16)
    ax.set_zlabel(<span class="org-string">'z-Achse'</span>, fontsize=16)


    <span class="org-comment-delimiter">#</span><span class="org-comment">set a limit on the z-axis/**sorry it's messy &lt;2023-03-02 Thu&gt; shoshin</span>
    ax.set_zlim(-4,4)

    <span class="org-comment-delimiter">#</span><span class="org-comment">clean the canvas no grid whatsoever or other oob stuff</span>
    ax.xaxis.pane.fill = <span class="org-constant">False</span>
    ax.yaxis.pane.fill = <span class="org-constant">False</span>
    ax.zaxis.pane.fill = <span class="org-constant">False</span>
    ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
    ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
    ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)

    ax.grid(<span class="org-constant">False</span>)
    font = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
    plt.rc(<span class="org-string">'font'</span>, **font)
    <span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Zylindrische Kavit&#228;t", fontsize=25)</span>
    plt.axis(<span class="org-string">'off'</span>)
    <span class="org-comment-delimiter">#</span><span class="org-comment">fig.savefig('ZylinderSystem.png', dpi=320)</span>
    plt.show()

<span class="org-comment-delimiter">#</span><span class="org-comment">create a figure for plotting</span>
fig = plt.figure()

<span class="org-comment-delimiter">#</span><span class="org-comment">create a 3d ax-element</span>
ax = fig.add_subplot(111, projection=<span class="org-string">'3d'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">adjust view on the art-piece</span>
ax.view_init(azim=-90, elev=90)
ax.set_axis_off()
plt.show()


<span class="org-comment-delimiter"># </span><span class="org-comment">Write parameters to be passed to above cylinder function</span>
radius = 50
height = 2
elevation = -1
resolution = 100
color = <span class="org-string">'lightskyblue'</span>
x_center = 0
y_center = 0

<span class="org-comment-delimiter"># </span><span class="org-comment">pass the parameter</span>
plot_3D_cylinder(radius, height, elevation=elevation, resolution=resolution, color=color, x_center=x_center, y_center=y_center)

<span class="org-comment-delimiter">#</span><span class="org-comment">save the figure</span>
plt.savefig(<span class="org-string">'img/matplot-azimuthal.png'</span>)
<span class="org-comment-delimiter">#</span><span class="org-comment">return 'img/matplot-azimuthal.png'</span>


</pre>
</div>


<div id="orgdeecdc5" class="figure">
<p><img src="./img/matplot-azimuthal.png" alt="matplot-azimuthal.png" title="AzimutaleFunktion" align="center" />
</p>
<p><span class="figure-number">Figure 2: </span>Die azimutale Funktion beschreibt die Umlaufrichtung</p>
</div>

\begin{equation}\label{eqn:azimuthal-Zahl}
  m = \frac{2\pi r n_{m}}{\lambda_{0}}
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="test" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(m\)</td>
<td class="org-left">Azimutale Quantenzahl</td>
</tr>

<tr>
<td class="org-left">\(r\)</td>
<td class="org-left">Radius</td>
</tr>

<tr>
<td class="org-left">\(n_{m}\)</td>
<td class="org-left">Brechungsindex</td>
</tr>
</tbody>
</table>

<p>
Der mathematische Ausdruck ist im Vergleich zum oberen Codebeispiel ziemlich unspektakulär:
</p>
\begin{equation}
     \Phi(\varphi) = e^{(jm \varphi)}
\end{equation}
</div>
</div>
</div>

<div id="outline-container-org59fd68c" class="outline-3">
<h3 id="org59fd68c">Funktion der Z-Koordinate bzw. der Höhe</h3>
<div class="outline-text-3" id="text-org59fd68c">
<p>
Für die Funktion \(Z(z)\) ergeben sich unterschiedliche Funktionen. Symmetrische, auch als unsymmetrische  Funktionen.
Das Liegt daran, dass sowohl Cosinus als auch Sinus zulässig sind.
</p>


\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
       A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big),   & \text{für } z < - \bigg(\frac{h}{2}\bigg) .\\
       B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big), & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
       A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg)
        \end{array}\right.
\end{equation}

<p>
und unsymmetrischen Lösungen:
</p>

\begin{equation}
     Z(z) = \left\{\begin{array}{lr}
        A \exp\Big(\sqrt{k_{eff}^{2} -k_{0}^{2}}z \Big),   & \text{für } z < -\bigg(\frac{h}{2}\bigg) .\\
        B sin\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big) , & \text{für } |z| < \bigg(\frac{h}{2}\bigg) ,\\
        - A \exp\Big(-\sqrt{k_{eff}^{2} -k_{0}^{2}}z\Big), & \text{für } z > \bigg(\frac{h}{2}\bigg).
        \end{array}\right.
\end{equation}

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" title="Wellenzahlen" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(k_{eff}\)</td>
<td class="org-left">effektive Wellenzahl einer Mode</td>
</tr>

<tr>
<td class="org-left">\(k_{i}\)</td>
<td class="org-left">Wellenzahl im Festkörper</td>
</tr>

<tr>
<td class="org-left">\(k_{0}\)</td>
<td class="org-left">Wellenzahl im Vakuum</td>
</tr>

<tr>
<td class="org-left">\(h\)</td>
<td class="org-left">Höhe eines Resonators</td>
</tr>
</tbody>
</table>

<p>
Die Höhe \(h\) gibt die Randbedingung für die Gültigkeit der Sinus/Cosinus Funktion für die $Z$-Koordinate wieder. Jenseits einer gegebenen Höhe sind andere Funktionen definiert, die mit zunehmendem/abnehmenden \(z\) exponential abfallen und gegen \(0\) gehen.
</p>
</div>

<div id="outline-container-org70a0a5e" class="outline-4">
<h4 id="org70a0a5e">Codebeispiel für die vertikale Richtung</h4>
</div>
</div>

<div id="outline-container-org368d7c7" class="outline-3">
<h3 id="org368d7c7">Die Radiale Funktion</h3>
<div class="outline-text-3" id="text-org368d7c7">
<p>
Für die radiale Funktion \(R(\rho)\) ergibt sich durch die Separation der Variablen Bessels-Differentialgleichung.
</p>

\begin{equation}\label{eqn:PreBessel}
    \rho^{2}\Big( \frac{d^{2}R}{d \rho^{2}}\Big) + (\rho^{2}k^{2}-m^{2})R = 0
\end{equation}

<p>
Durch die Substitution \(\mathbf{k \rho = x}\) ist der Ausdruck aus Gleichung als die allgemeine Form darstellbar.
</p>

\begin{equation}
    x^{2}\frac{d^{2}R}{dx^{2}}+\frac{dR}{dx}+(x^{2}-m^{2})R = 0
\end{equation}

<p>
Diese Differentialgleichung kann durch Besselfunktionen und Hankelfunktionen erster Gattung gelöst werden. Das Innere des Resonators wird dabei durch Besselfunktionen beschrieben.
</p>
\begin{equation}
   R(\rho) = J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big), \hspace{0.5cm} \rho < r
\end{equation}
</div>


<div id="outline-container-org09b6ac1" class="outline-4">
<h4 id="org09b6ac1">Codebeispiel der Besselfunktionen</h4>
<div class="outline-text-4" id="text-org09b6ac1">
<p>
Im Folgenden wird in Python ein Codebeispiel gezeigt, in welchem das Innere eines Resonators dargestellt wird. Es veranschaulicht eine radiale Veränderung des Elektromagnetischen Feldes.
</p>
</div>
</div>

<div id="outline-container-org3dfdebd" class="outline-4">
<h4 id="org3dfdebd">Codebeispiel der radialen Funktion innerhalb des Resonators</h4>
<div class="outline-text-4" id="text-org3dfdebd">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib
<span class="org-keyword">from</span> scipy.special <span class="org-keyword">import</span> hankel1e, y1_zeros
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d

<span class="org-comment-delimiter">#</span><span class="org-comment">needed for 3D-coordinate system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_verts3d</span> = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        xs3d, ys3d, zs3d = <span class="org-keyword">self</span>._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">using circular coordinates again! range of theta-axis is needed</span>
thetaAng = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">assume the edge of the resonator to be rAng = 50</span>
rAng =  50.0
x1 = rAng * np.cos(thetaAng) + 0
x2 = rAng * np.sin(thetaAng) + 0

<span class="org-comment-delimiter">#</span><span class="org-comment">prepare the canvas and axis for the function</span>
fig=plt.figure(figsize=(5,5))
ax = Axes3D(fig, azim=45, elev=21)

<span class="org-comment-delimiter">#</span><span class="org-comment">create coordinate arrows for cylindrical and cartesian directions</span>
arrow_prop_dict = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)
a = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)


<span class="org-comment-delimiter">#</span><span class="org-comment">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span class="org-string">'$o$'</span>)
ax.text(0, 55, 0, r<span class="org-string">'$\rho$'</span>)
ax.text(45, 45, 0, r<span class="org-string">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span class="org-string">'$z$'</span>)
ax.text(75, 0, 0, r<span class="org-string">'$x$'</span>)
ax.text(0, 70, 0, r<span class="org-string">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span class="org-string">'$R(\rho)$'</span>)


<span class="org-comment-delimiter">#</span><span class="org-comment">create the bessel-function</span>
<span class="org-keyword">def</span> <span class="org-function-name">drumhead_height</span>(n, k, distance, angle, t):

   kth_zero = sp.jn_zeros(n, k)[-1]

   <span class="org-keyword">return</span> np.cos(t) * np.cos(n*angle) * sp.jn(n, distance*kth_zero)

<span class="org-comment-delimiter">#</span><span class="org-comment">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
theta = np.r_[0:2*np.pi:50j]
radius = np.r_[0:50:50j]

<span class="org-comment-delimiter">#</span><span class="org-comment">transform cartesian coordinates into cylindrical ones</span>
x = np.array([r * np.cos(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
y = np.array([r * np.sin(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
z = np.array([drumhead_height(0,2, r, theta,1) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])


<span class="org-comment-delimiter">#</span><span class="org-comment">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span class="org-string">'jet'</span>,alpha=0.5)

<span class="org-comment-delimiter">#</span><span class="org-comment">set axis names and labels</span>
ax.set_xlabel(<span class="org-string">'x'</span>)
ax.set_ylabel(<span class="org-string">'y'</span>)
ax.set_zlabel(<span class="org-string">'z'</span>)

ax.set_xlabel(<span class="org-string">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span class="org-comment-delimiter">#</span><span class="org-comment">strip the figure of unnecessary stuff</span>
ax.xaxis.pane.fill = <span class="org-constant">False</span>
ax.yaxis.pane.fill = <span class="org-constant">False</span>
ax.zaxis.pane.fill = <span class="org-constant">False</span>
ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
font = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
plt.rc(<span class="org-string">'font'</span>, **font)
<span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span class="org-string">'off'</span>)
fig.tight_layout(pad=1.0)
<span class="org-comment-delimiter">#</span><span class="org-comment">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span class="org-string">'./img/BRadialeFunktion.png'</span>)
plt.show()



</pre>
</div>


<div id="org0667834" class="figure">
<p><img src="./img/BRadialeFunktion.png" alt="BRadialeFunktion.png" title="Bessel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 3: </span>Die Funktion die radial die Umlaufrichtung beschreibt</p>
</div>
</div>
</div>


<div id="outline-container-orgd1b83a9" class="outline-4">
<h4 id="orgd1b83a9">Codebeispiel der radialen Funktion außerhalb des Resonators</h4>
<div class="outline-text-4" id="text-orgd1b83a9">
<p>
Außerhalb der endlichen Geometrie des Resonator fallen die Ausprägungen des elektromagntischen Feldes stark ab. Durch Hankelfunktionen wird diesem Umstand mathematisch
Rechung getragen.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> scipy.special <span class="org-keyword">as</span> sp
<span class="org-keyword">import</span> matplotlib
<span class="org-keyword">from</span> scipy.special <span class="org-keyword">import</span> hankel1e, y1_zeros
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> Axes3D
matplotlib.use(<span class="org-string">'Agg'</span>)
<span class="org-keyword">import</span> matplotlib.pyplot <span class="org-keyword">as</span> plt
<span class="org-keyword">from</span> matplotlib.patches <span class="org-keyword">import</span> FancyArrowPatch
<span class="org-keyword">from</span> mpl_toolkits.mplot3d <span class="org-keyword">import</span> proj3d

<span class="org-comment-delimiter">#</span><span class="org-comment">needed for 3D-coordinate system</span>
<span class="org-keyword">class</span> <span class="org-type">Arrow3D</span>(FancyArrowPatch):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, xs, ys, zs, *args, **kwargs):
        <span class="org-builtin">super</span>().__init__((0,0), (0,0), *args, **kwargs)
        <span class="org-keyword">self</span>.<span class="org-variable-name">_verts3d</span> = xs, ys, zs

    <span class="org-keyword">def</span> <span class="org-function-name">do_3d_projection</span>(<span class="org-keyword">self</span>, renderer=<span class="org-constant">None</span>):
        xs3d, ys3d, zs3d = <span class="org-keyword">self</span>._verts3d
        xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, <span class="org-keyword">self</span>.axes.M)
        <span class="org-keyword">self</span>.set_positions((xs[0],ys[0]),(xs[1],ys[1]))

        <span class="org-keyword">return</span> np.<span class="org-builtin">min</span>(zs)

<span class="org-comment-delimiter">#</span><span class="org-comment">using circular coordinates again! range of theta-axis is needed</span>
thetaAng = np.linspace(0,np.pi/2,100)  <span class="org-comment-delimiter"># </span><span class="org-comment">0 &lt;= &#952; &lt;= 2&#960;</span>

<span class="org-comment-delimiter">#</span><span class="org-comment">assume the edge of the resonator to be rAng = 50</span>
rAng =  50.0
x1 = rAng * np.cos(thetaAng) + 0
x2 = rAng * np.sin(thetaAng) + 0

<span class="org-comment-delimiter">#</span><span class="org-comment">prepare the canvas and axis for the function</span>
fig=plt.figure(figsize=(5,5))
ax = Axes3D(fig, azim=45, elev=21)

<span class="org-comment-delimiter">#</span><span class="org-comment">create coordinate arrows for cylindrical and cartesian directions</span>
arrow_prop_dict = <span class="org-builtin">dict</span>(mutation_scale=20, arrowstyle=<span class="org-string">'-&gt;'</span>, shrinkA=0, shrinkB=0)

a = Arrow3D([0, 0], [0, 70], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 70], [0, 0], [0, 0], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.8], **arrow_prop_dict, color=<span class="org-string">'black'</span>,linestyle=<span class="org-string">"dashed"</span>,linewidth=1.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 0], [0, 0.7], **arrow_prop_dict, color=<span class="org-string">'blue'</span>,linewidth=5.0)
ax.add_artist(a)
a = Arrow3D([0, 0], [0, 55], [0, 0], **arrow_prop_dict, color=<span class="org-string">'red'</span>,linewidth=5.0)
ax.add_artist(a)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the phi-coordinate</span>
ax.plot(x1, x2, color=<span class="org-string">'g'</span>,linewidth=5.0)

<span class="org-comment-delimiter">#</span><span class="org-comment">add symbols for orientation</span>
ax.text(0, -2, -.06, r<span class="org-string">'$o$'</span>)
ax.text(0, 55, 0, r<span class="org-string">'$\rho$'</span>)
ax.text(45, 45, 0, r<span class="org-string">'$\varphi$'</span>)
ax.text(0, -2, 0.81, r<span class="org-string">'$z$'</span>)
ax.text(75, 0, 0, r<span class="org-string">'$x$'</span>)
ax.text(0, 70, 0, r<span class="org-string">'$y$'</span>)
ax.text(-20, 15, 0.25, r<span class="org-string">'$R(\rho)$'</span>)

<span class="org-comment-delimiter">#</span><span class="org-comment">create the hankel-function</span>
<span class="org-keyword">def</span> <span class="org-function-name">drumhead_height</span>(n, k, distance, angle, t):

   kth_zero = sp.jn_zeros(n, k)[-1]

   <span class="org-keyword">return</span> np.cos(t) * np.cos(n*angle) * sp.hankel1e(n, distance*kth_zero)

<span class="org-comment-delimiter">#</span><span class="org-comment">focus on the interesting part of the hankel function --outside the cylinder reminder: it's not defined inside</span>
theta = np.r_[0:2*np.pi:50j]
radius = np.r_[55:75:50j]

<span class="org-comment-delimiter">#</span><span class="org-comment">transform cartesian coordinates into cylindrical ones</span>
x = np.array([r * np.cos(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
y = np.array([r * np.sin(theta) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])
z = np.array([drumhead_height(0,2, r, theta,1) <span class="org-keyword">for</span> r <span class="org-keyword">in</span> radius])

<span class="org-comment-delimiter">#</span><span class="org-comment">plot the results outside</span>
ax.plot_surface(x[1:50], y[1:50], z[1:50], rstride=1, cstride=1, cmap=<span class="org-string">'jet'</span>,alpha=0.5)

<span class="org-comment-delimiter">#</span><span class="org-comment">set axis names and labels</span>
ax.set_xlabel(<span class="org-string">'x'</span>)
ax.set_ylabel(<span class="org-string">'y'</span>)
ax.set_zlabel(<span class="org-string">'z'</span>)

ax.set_xlabel(<span class="org-string">'Radius [$kR$]'</span>, labelpad=20 ,fontsize=16)
ax.set_ylabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)
ax.set_zlabel(<span class="org-string">'H&#246;he [$hk$]'</span>, labelpad=20, fontsize=16)

ax.set_zlim3d(0,1)

<span class="org-comment-delimiter">#</span><span class="org-comment">strip the figure of unnecessary stuff</span>
ax.xaxis.pane.fill = <span class="org-constant">False</span>
ax.yaxis.pane.fill = <span class="org-constant">False</span>
ax.zaxis.pane.fill = <span class="org-constant">False</span>
ax.xaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.yaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
ax.zaxis.pane.set_edgecolor(<span class="org-string">'w'</span>)
font = {<span class="org-string">'family'</span> : <span class="org-string">'sans-serif'</span>,
        <span class="org-string">'weight'</span> : <span class="org-string">'normal'</span>,
        <span class="org-string">'size'</span>   : 20}
plt.rc(<span class="org-string">'font'</span>, **font)
<span class="org-comment-delimiter">#</span><span class="org-comment">fig.suptitle("Bessel", fontsize=25)</span>
plt.axis(<span class="org-string">'off'</span>)
fig.tight_layout(pad=1.0)
<span class="org-comment-delimiter">#</span><span class="org-comment">plt.title('Radiale Funktion', x=0.525, y=0.75)</span>
fig.savefig(<span class="org-string">'./img/HRadialeFunktion.png'</span>)
plt.show()


</pre>
</div>


<div id="org9979bc9" class="figure">
<p><img src="./img/HRadialeFunktion.png" alt="HRadialeFunktion.png" title="Hankel-Funktion" align="center" />
</p>
<p><span class="figure-number">Figure 4: </span>Die Funktion die radial die Umlaufrichtung beschreibt</p>
</div>

<p>
Zu einer Funktion mit dem Index \(m\) können mehrere Nullstellen gefunden werden, deren Lage aus Tabellen bekannt ist&#x2026; Mit einem gewählten Radius \(r\) und einer Wellenzahl \(k\) können die Nullstellen für ein System bestimmt werden.
</p>

<p>
Mit den drei Quantenzahlen kann eine Eigenmode in einem Zylinder bestimmt werden. Für die Moden im Inneren des Zylinders ist die Funktion der symmetrischen Lösung gegeben durch:
</p>

\begin{equation}
        \mathbf{E(r)}_{q,l,m} =  J_{m}\Big(\frac{k_{eff}\cdot \rho}{r}\Big) B cos\Big(\sqrt{k_{i}^{2} -k_{eff}^{2}}z \Big)\exp^{jm\varphi}
\end{equation}

<p>
In den hier vorgestellten Verhältnissen ist \(k_{eff}\) nicht bekannt. Aus der Bedingung, dass das magnetische Feld \(B(r) = -\frac{j}{\omega} \nabla\times E(r)\) an dem Übergang  \(\rho = r\) kontinuierlich ist, ergibt sich das Verhältnis, dass die radiale innere Lösung an diesem Punkt gleich der radialen äußeren Lösung sein muss.
</p>

\begin{equation}\label{eqn:effektiveWellenzahl}
    k_{eff}\frac{[J_{m}(k_{eff}\cdot r)]'}{J_{m}(k_{eff}\cdot r)}   = k_{0} \frac{[H^{1}_{m}(k_{0}\cdot r)]'}{H^{1}_{m}(k_{0}\cdot r)}
\end{equation}

<p>
Die Änderung der Funktion \([J_{m}(k_{eff}\cdot r)]'\) bzw. \([H^{1}_{m}(k_{0}\cdot r)]'\)  kann durch eine Finite-Elementen-Analyse numerisch genähert und gelöst werden. Dadurch kann die effektive Wellenzahl einer Mode gefunden werden.
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-org0d90540" class="outline-2">
<h2 id="org0d90540">Numerische Approximation</h2>
<div class="outline-text-2" id="text-org0d90540">
<p>
Lösungen der Maxwellgleichungen können numerisch approximiert werden. Dabei werden zu untersuchende Strukturen auf einem Rechengitter projiziert. Ein einfaches Rechengitter lässt sich über folgenden Code in C realisieren
</p>
</div>
<div id="outline-container-org0d4713e" class="outline-3">
<h3 id="org0d4713e">Codebeispiel: ACHTUNG DIESER CODE WIRD NOCH VERLAGERT ER IST ZUVIEL ;)</h3>
<div class="outline-text-3" id="text-org0d4713e">
<div class="org-src-container">
<pre class="src src-cuda">#include &lt;algorithm&gt;
#include &lt;cublas.h&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;math.h&gt;
#include &lt;string.h&gt;
#include &lt;thrust/complex.h&gt;
#include &lt;thrust/device_vector.h&gt;
#include &lt;thrust/execution_policy.h&gt;
#include &lt;thrust/for_each.h&gt;
#include &lt;thrust/functional.h&gt;
#include &lt;thrust/gather.h&gt;
#include &lt;thrust/host_vector.h&gt;
#include &lt;thrust/iterator/counting_iterator.h&gt;
#include &lt;thrust/iterator/transform_iterator.h&gt;
#include &lt;thrust/iterator/zip_iterator.h&gt;
#include &lt;thrust/partition.h&gt;
#include &lt;thrust/fill.h&gt;
#include &lt;thrust/transform.h&gt;
#include &lt;thrust/scatter.h&gt;
#include &lt;thrust/sequence.h&gt;
#include &lt;thrust/tuple.h&gt;
#include &lt;vector&gt;
#include &lt;cusolverSp.h&gt;
#include &lt;cusparse.h&gt;
#include "cusolver_utils.h"
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;

template &lt;typename Iterator&gt; class strided_range {
public:
  typedef typename thrust::iterator_difference&lt;Iterator&gt;::type difference_type;

  struct stride_functor
      : public thrust::unary_function&lt;difference_type, difference_type&gt; {
    difference_type stride;

    stride_functor(difference_type stride) : stride(stride) {}

    __host__ __device__ difference_type
    operator()(const difference_type &amp;i) const {
      return stride * i;
    }
  };


  typedef typename thrust::counting_iterator&lt;difference_type&gt; CountingIterator;
  typedef typename thrust::transform_iterator&lt;stride_functor, CountingIterator&gt;
      TransformIterator;
  typedef typename thrust::permutation_iterator&lt;Iterator, TransformIterator&gt;
      PermutationIterator;

  // type of the strided_range iterator
  typedef PermutationIterator iterator;

  // construct strided_range for the range [first,last)
  strided_range(Iterator first, Iterator last, difference_type stride)
      : first(first), last(last), stride(stride) {}

  iterator begin(void) const {
    return PermutationIterator(
	first, TransformIterator(CountingIterator(0), stride_functor(stride)));
  }

  iterator end(void) const {
    return begin() + ((last - first) + (stride - 1)) / stride;
  }

protected:
  Iterator first;
  Iterator last;
  difference_type stride;
};

// SPARSE MATRIX DIVISION
struct sparseDivision
{
    __host__ __device__
    thrust::tuple&lt;float,float&gt; operator()(const thrust::tuple&lt;float,float&gt;&amp; spMat, const thrust::tuple&lt;float&gt; &amp;divi) const
    {
      auto out = thrust::make_tuple(thrust::get&lt;0&gt;(spMat)/thrust::get&lt;0&gt;(divi),thrust::get&lt;1&gt;(spMat)/thrust::get&lt;0&gt;(divi));
      return out;
    }

};

// SPARSE MATRIX MULTIPLICATION

__global__ void SpMM(float *d_A, float *d_B, float *d_C, int barrier, int* d_elem_scan, int *d_row_ptr, int *d_col_ptr)
{
int focus = blockIdx.x * blockDim.x + threadIdx.x;
    if ((focus &lt; barrier))
	{

	float temp = 0;
	int k = 0;
	int d_elem_start = d_elem_scan[focus];
	int d_elem_end = d_elem_scan[focus+1];

	int elem = d_elem_end - d_elem_start;
	for(int i = 0; i &lt; elem; i++)
	{
	  //this is a temp fix because otherwise the wrong col-element gets pulled
	  //A fix will be implemented within generalized upcoming linear algebra routines
	  if(i==1)
	  {
	    temp += d_A[d_row_ptr[focus+i]] * d_B[d_col_ptr[focus+i+1]];
	  }

	 else
	 {
	    temp += d_A[d_row_ptr[focus+i]] * d_B[d_col_ptr[focus+i]];
	 }
	    //DEBUGGING
	    //uncomment to see why the fix above is neccessary; the root of the problems lies within the combination of threading and loop-increment
	    //printf(" thread: %i  row: %i  col: %i  inc: %i escan: %i temp: %f \n", focus,d_row_ptr[focus +i], d_col_ptr[focus +i], i, elem, temp );
	}
	d_C[focus] = temp;
	}
    }

void DiagAdd(float *diagonal, float* addMe, int diagSize )
{

    for(int diagIdx = 0; diagIdx &lt; diagSize; ++diagIdx)
	{
		if(diagIdx % 3 == 0)
			{
			    diagonal[diagIdx] =diagonal[diagIdx] + addMe[diagIdx/3];
			}
	}
}

//// Sequences for Matrix-Elements outside of CUDA-Kernels
//void CreateRow_Ptr(int* h_rows,int size)
//     {
//        int input = 1;
//        for (int  i = 0; i &lt; size; i+=2)
//        {
//            if(i == 0)
//                {
//                h_rows[i] = 0;
//                }
//            for(int k = 1; k &lt; 3; ++k)
//                {
//                    h_rows[i+k] = input;
//                }
//            ++input;
//        }
//     }
//
//void CreateCol_Ptr(int* h_cols, int size)
//     {
//         bool focus;
//         int barrier = 4;
//         int elem1 = 1;
//         int elem2 = 1;
//
//         h_cols[0] =0;
//         int i = 1;
//
//         while(i &lt; size)
//         {
//             if(barrier &gt; 2)
//             {
//                 h_cols[i] = elem1;
//                 ++elem1;
//                 barrier--;
//                 focus = false;
//                 ++i;
//             }
//
//             if(barrier == 2)
//             {
//                 if(focus == false)
//                     barrier = 0;
//
//                 if(focus == true)
//                     barrier = 4;
//             }
//
//             if( barrier &lt; 2)
//             {
//                 h_cols[i] = elem2;
//                 ++elem2;
//                 ++barrier;
//                 focus = true;
//                 ++i;
//             }
//
//         }
//     }
//
//
void CreateElem_Scan(int *elem_list, int size)
     {
	int offset = 2;
	int inc = 0;
	int i = 0;
	while (i &lt; size)
	{

	    if(i == 0)
		{
		    elem_list[i]=0;
		    ++i;
		}


	    if(offset == 2)
	    {
		inc +=2;
		elem_list[i] = inc;
		offset = 0;
		++i;
	    }

	    else
	    {
		++inc;
		elem_list[i] =inc;
		++offset;
		++i;
	    }
	}

     }

struct vectorInversion
{
    __host__ __device__
    float operator()(const float&amp; vec) const
    {
      auto out = 1/vec;
      return out;
    }

};

template &lt;typename V&gt;

void print_matrix(const V &amp;A, int nr_rows_A, int nr_cols_A) {

  for (int i = 0; i &lt; nr_rows_A; ++i) {
    for (int j = 0; j &lt; nr_cols_A; ++j) {
      std::cout &lt;&lt; A[j * nr_rows_A + i] &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
  }
  std::cout &lt;&lt; std::endl;
}

//Sequence for Col-Elements in threading scheme
void kernelCols(int *cols, int size)
{
    int barrier = 1;
    int even = 2;
    int normal = 0;
    for(int i = 0;  i &lt; size; ++i)
	{
	    if((barrier) !=2 || (i == 0) ){
		cols[i] = normal;
		++normal;
		++barrier;
		}

	    else if((barrier == 2) &amp;&amp;( i != 0))
	    {
		    cols[i]  = even;
		    barrier=0;
		    even+=2;
	    }
	    }
}

//Sequence for Row-Elements in threading scheme
void kernelRows(int *rows, int size)
    {

    int inc = 0;
    int k = 0;
    while(k &lt;size)
	{
	    if((k!=0)&amp;&amp;(k%3==0))
		{
		rows[k] = inc-1;
		++k;
		}
	    rows[k]=inc;
	    ++inc;
	    ++k;
	    }
    }

void creat_sp_rows_ptr(int* sp_rows, int size)
    {
	int incr = -1;
	int first= 0;
	for(int i = 0; i &lt; size; ++i)
	{

	    sp_rows[i] = incr;
	    if((i &lt; 2))
	      {
		sp_rows[i] = first;
		first+=2;
	      }
	    incr+=3;
	}
    }

void creat_sp_cols_ptr(int* sp_cols, int size  )
    {
     int incr = 0;
     int barrier = 3;


	for(int i = 0; i &lt; size; ++i)
	    {
		if(barrier == 0)
		    {
		      incr -= 2;
		      barrier = 3;
		      //printf("inside 1st \n");
		    }

		//neccessary
		if((incr == 2)&amp;&amp;( i == 2))
		    {
		      incr -= 2;
		      barrier = 3;
		      //printf("inside 2nd\n");
		    }
		sp_cols[i] = incr;
		incr++;
		--barrier;
	    }
    }

//&lt;---------------------Execute--------------------&gt;

int main() {

  float micrometers = 1;
  float nanometers = 1e-3 * micrometers;

  // WAVELENGTH AND MODE
  float lam0 = 1.55 * micrometers; //
  char MODE = 'H';

  // SLAB WAVEGUIDE
  float a = 1500 * nanometers;
  float n1 = 1.0;
  float n2 = 2.0;
  float n3 = 1.5;

  // GRID PARAMETERS
  float nmax = n2;
  float NRES = 20;    // 56.888990026/2;
  float b = 3 * lam0; // 3

  // NUMBER OF MODES TO CALCULATE
  float NMODES = 4;

  int m = 1;

  float dx = lam0 / nmax / NRES;
  float nx = ceil(a / dx);

  dx = a / nx;

  float Sx = b + a + b;
  float Nx = ceil(Sx / dx);
   Sx = Nx * dx;

  int Nx2 = 2 * Nx;
  float dx2 = dx / 2;
  int size = Nx;
  //  thrust::fill(xa.begin(), xa.end(),1);

  // CREATE X-AXIS
  thrust::device_vector&lt;float&gt; xa(Nx + 2); //+2

  // AXIS STARTS AT 1 to 284
  thrust::counting_iterator&lt;float&gt; iter(1);
  thrust::copy(iter, iter + xa.size(), xa.begin());

  // MULTIPLY AXIS-UNITS WITH THE STEPSIZE " dx "
  thrust::transform(xa.begin(), xa.end(), thrust::make_constant_iterator(dx),
		    xa.begin(), thrust::multiplies&lt;float&gt;());

  // INITIALIZE ARRAY WITH ONES
  thrust::device_vector&lt;float&gt; m_xa(Nx);
  thrust::fill(m_xa.begin(), m_xa.end(), 1);

  // CALCULATE MEAN OF THE THE STEP-SIZE-ARRAY SCALE
  float xmean = thrust::reduce(xa.begin(), xa.end()) / size;

  // SUBSTRACT THE MEAN FROM THE STEP-SIZE ARRAY
  using namespace thrust::placeholders;
  thrust::for_each(xa.begin(), xa.end(), _1 -= xmean);

  // CREATE MAGNETIC AND ELECTRIC ARRAY
  thrust::device_vector&lt;float&gt; ER2(Nx2);
  thrust::device_vector&lt;float&gt; UR2(Nx2);

  // DETERMINE THE ARRAY STARTING POSITIONS
  float nx1 = 1 + ceil(b / dx);
  float nx2 = 1 + round(b / dx2) - 1;

  // BUILD SLAB WAVEGUIDE
  // E-FIELD
  thrust::fill(ER2.begin(), ER2.begin() + 2*(nx1-1), n1*n1);
  thrust::fill(ER2.begin() + 2*(nx1-1), ER2.end() - (nx2-2), n2*n2);
  thrust::fill(ER2.end() - (nx2-2), ER2.end(), n3*n3);

  // BUILD SLAB WAVEGUIDE
  // M-FIELD

  // EXTRACT YEE GRID ARRAYS ERxx: odd Array-Elements, ERyy &amp; ERzz: even
  // Array-Elements
  typedef thrust::device_vector&lt;float&gt;::iterator Iterator;
  strided_range&lt;Iterator&gt; ERxx(ER2.begin() + 1, ER2.end(), 2);
  strided_range&lt;Iterator&gt; ERyy(ER2.begin(), ER2.end(), 2);
  strided_range&lt;Iterator&gt; ERzz(ER2.begin(), ER2.end(), 2);

  strided_range&lt;Iterator&gt; URxx(UR2.begin(), UR2.end(), 2);
  strided_range&lt;Iterator&gt; URyy(UR2.begin() + 1, UR2.end(), 2);
  strided_range&lt;Iterator&gt; URzz(UR2.begin() + 1, UR2.end(), 2);

  // CREATE VECTORS B.C. of TO BE ABLE TO TYPECAST PROPERPLY
  thrust::device_vector&lt;float&gt; dERxx(size);
  thrust::device_vector&lt;float&gt; dERyy(size);
  thrust::host_vector&lt;float&gt; dERzz(size);

  thrust::device_vector&lt;float&gt; dURxx(size);
  thrust::host_vector&lt;float&gt; dURyy(size);
  thrust::device_vector&lt;float&gt; dURzz(size);

  // COPY THE ITERATORS INTO VECTOR CONTAINERS
  thrust::copy(thrust::device, ERxx.begin(), ERxx.end(), dERxx.begin());
  thrust::copy(thrust::device, ERyy.begin(), ERyy.end(), dERyy.begin());
  thrust::copy(thrust::host, ERzz.begin(), ERzz.end(), dERzz.begin());

  thrust::fill(dURyy.begin(), dURyy.end(), 1);
  thrust::copy(thrust::device, URxx.begin(), URxx.end(), dURxx.begin());
  //thrust::copy(thrust::device, URyy.begin(), URyy.end(), dURyy.begin());
  thrust::copy(thrust::device, URzz.begin(), URzz.end(), dURzz.begin());


  thrust::device_vector&lt;float&gt; dERxx2(size * size);
  thrust::copy(thrust::device, ERxx.begin(), ERxx.end(), dERxx2.begin());

  // BUILD DERIVATIVE MATRICES
  float k0 = 2 * M_PI / lam0;
  float NS[2] = {Nx, 1};
  float RES[2] = {dx, 1};
  int BC[2] = {0, 0};

  float d_Ns[2] = {Nx, 1};

   Nx = d_Ns[0];
  int Ny = d_Ns[1];

  float dy = RES[1];

  float kinc[2] = {0, 0};

  int M = Nx * Ny;


//BUILD DEX
  thrust::host_vector&lt;float&gt;mid_Diag(size);
  thrust::host_vector&lt;float&gt;top_Diag(size);

  thrust::fill(mid_Diag.begin(), mid_Diag.end(), -1);
  thrust::fill(top_Diag.begin(), top_Diag.end(), 1);

  //thrust::transform(sub_Diag.begin(), sub_Diag.end(), thrust::make_constant_iterator(dx), sub_Diag.begin(), thrust::divides&lt;float&gt;());
  thrust::transform(mid_Diag.begin(), mid_Diag.end(), thrust::make_constant_iterator(dx), mid_Diag.begin(), thrust::divides&lt;float&gt;());
  thrust::transform(top_Diag.begin(), top_Diag.end(), thrust::make_constant_iterator(dx), top_Diag.begin(), thrust::divides&lt;float&gt;());

//BUILD DHX
  thrust::host_vector&lt;float&gt;subDH_Diag(size);

  thrust::host_vector&lt;float&gt;midDH_Diag(size);

  thrust::fill(subDH_Diag.begin(), subDH_Diag.end(), -1);
  thrust::fill(midDH_Diag.begin(), midDH_Diag.end(), 1);

  thrust::transform(subDH_Diag.begin(), subDH_Diag.end(), thrust::make_constant_iterator(dx), subDH_Diag.begin(), thrust::divides&lt;float&gt;());
  thrust::transform(midDH_Diag.begin(), midDH_Diag.end(), thrust::make_constant_iterator(dx), midDH_Diag.begin(), thrust::divides&lt;float&gt;());


//PREPARE DIVISION  DEX/ERzz
//

  typedef thrust::host_vector&lt;float&gt;::iterator midDiag;
  typedef thrust::host_vector&lt;float&gt;::iterator topDiag;

  typedef thrust::tuple&lt;midDiag,topDiag&gt; IteratorTuple;
  typedef thrust::zip_iterator&lt;IteratorTuple&gt; ZipIterator;

  ZipIterator zipper(thrust::make_tuple(subDH_Diag.begin(), midDH_Diag.begin()));

  auto d_DEX_begin =  thrust::make_zip_iterator(thrust::make_tuple(&amp;mid_Diag[0], &amp;top_Diag[0]));
  auto d_DEX_end =  thrust::make_zip_iterator(thrust::make_tuple(&amp;mid_Diag[size], &amp;top_Diag[size]));

  thrust::host_vector&lt;float&gt; h_Bvec;

    thrust::for_each(d_DEX_begin, d_DEX_end,
		   [&amp;h_Bvec] (const thrust::tuple&lt;float, float&gt;&amp; tup)
		   {
		       h_Bvec.push_back(thrust::get&lt;0&gt;(tup));
		       h_Bvec.push_back(thrust::get&lt;1&gt;(tup));
		   });


  thrust::transform(h_Bvec.begin(), h_Bvec.end(), thrust::make_constant_iterator(-1), h_Bvec.begin(), thrust::multiplies&lt;float&gt;());
  thrust::device_vector&lt;float&gt; d_Bvec(562);
  thrust::copy(h_Bvec.begin(), h_Bvec.end()-1, d_Bvec.begin());




  auto d_ERzz_begin = thrust::make_zip_iterator(thrust::make_tuple(&amp;dERzz[0]));
  auto d_ERzz_end   = thrust::make_zip_iterator(thrust::make_tuple(&amp;dERzz[size]));

  thrust::host_vector&lt;float&gt; h_topResOut(size);
  thrust::host_vector&lt;float&gt; h_midResOut(size);

  thrust::zip_iterator&lt;thrust::tuple&lt;thrust::host_vector&lt;float&gt;::iterator,thrust::host_vector&lt;float&gt;::iterator&gt;&gt; zip_begin(thrust::make_tuple(mid_Diag.begin(), top_Diag.begin()));

  thrust::zip_iterator&lt;thrust::tuple&lt;thrust::host_vector&lt;float&gt;::iterator,thrust::host_vector&lt;float&gt;::iterator&gt;&gt; zip_end(thrust::make_tuple(mid_Diag.end(), top_Diag.end()));

  auto d_divRes_begin = thrust::make_zip_iterator(thrust::make_tuple(h_midResOut.begin(), h_topResOut.begin()));
  auto d_divRes_end = thrust::make_zip_iterator(thrust::make_tuple(h_midResOut.end(), h_topResOut.end()));

  //GET THE DIVISION FUNCTOR READY AND DIVIDE
  sparseDivision divByERzz;

  thrust::transform(zip_begin, zip_end, d_ERzz_begin, d_divRes_begin, divByERzz);

  thrust::host_vector&lt;float&gt; h_Avec;


  //thrust::transform(top_Diag.begin(), top_Diag.end(), thrust::make_constant_iterator(dx), top_Diag.begin(), thrust::divides&lt;float&gt;());



  thrust::for_each(d_divRes_begin, d_divRes_end,
		   [&amp;h_Avec] (const thrust::tuple&lt;float, float&gt;&amp; tup)
		   {
		       h_Avec.push_back(thrust::get&lt;0&gt;(tup));
		       h_Avec.push_back(thrust::get&lt;1&gt;(tup));
		   });


  thrust::device_vector&lt;float&gt; d_Avec(562);

  thrust::copy(h_Avec.begin(), h_Avec.end()-1, d_Avec.begin());





  //DO THE MULTIPLICATION

  // 1. CREATE THE ARRAYS OUT OF TU
  // {
  // PLE STRUCTURE
  // 2. CREATE THE row_prt and col_ptr ARRAYS

  // 3. FEED INTO THE SPARSE MATRIX MULTIPLICATION

//sizeof(thrust::get&lt;0&gt;(spMat)

  int* row_ptr;
  int* col_ptr;
  int* elem_scan;

  int ptr_size = 842;
  int ptr_size_buffer = 840;
  row_ptr   = (int *)malloc(ptr_size_buffer*sizeof(int));
  col_ptr   = (int *)malloc(ptr_size_buffer*sizeof(int));
  elem_scan = (int *)malloc(ptr_size_buffer*sizeof(int));

  float* d_C ;

  //float* d_A = thrust::raw_pointer_cast(d_Avec.data());
  //float* d_B = thrust::raw_pointer_cast(d_Bvec.data());
  //cudaMemcpy(&amp;d_A, &amp;h_A, ptr_size*sizeof(float), cudaMemcpyHostToDevice);

  CreateElem_Scan(elem_scan,ptr_size);
  kernelCols(col_ptr, ptr_size-1);
  kernelRows(row_ptr, ptr_size-1);
//
  int* d_col_ptr;
  int* d_row_ptr;
  int* d_elem_scan;
//
  cudaMalloc((void**) &amp;d_col_ptr, ptr_size*sizeof(int));
  cudaMalloc((void**) &amp;d_row_ptr, ptr_size*sizeof(int));
  cudaMalloc((void**) &amp;d_elem_scan, ptr_size*sizeof(int));
//
  cudaMalloc((void**) &amp;d_C, ptr_size*sizeof(float));
//
  cudaMemcpy(d_col_ptr, col_ptr, ptr_size*sizeof(int), cudaMemcpyHostToDevice);
  cudaMemcpy(d_row_ptr, row_ptr, ptr_size*sizeof(int), cudaMemcpyHostToDevice);
  cudaMemcpy(d_elem_scan, elem_scan, ptr_size*sizeof(int), cudaMemcpyHostToDevice);






  SpMM&lt;&lt;&lt;1,ptr_size&gt;&gt;&gt;(thrust::raw_pointer_cast(&amp;d_Avec[0]),thrust::raw_pointer_cast(&amp;d_Bvec[0]), d_C, ptr_size, d_elem_scan, d_row_ptr, d_col_ptr);
//
  float* h_C;
  h_C = (float *)malloc(ptr_size*sizeof(float));

  cudaMemcpy(h_C, d_C, ptr_size*sizeof(float), cudaMemcpyDeviceToHost);

  thrust::host_vector&lt;float&gt; hURyy(size);
  thrust::copy(dURyy.begin(), dURyy.end(), hURyy.begin());

  DiagAdd(h_C, thrust::raw_pointer_cast(&amp;hURyy[0]), ptr_size);


  for(int i = 0; i &lt;= ptr_size_buffer; ++i)
      {
	  std::cout &lt;&lt; "IdX " &lt;&lt; i &lt;&lt; ": " &lt;&lt; h_C[i] &lt;&lt;", ";
      }


 // vectorInversion vecInv;

 // thrust::host_vector &lt;float&gt; inv_dERzz(size);

  //thrust::transform(dERzz.begin(), dERzz.end(), inv_dERzz.begin(), vecInv);
  //size_t n = sizeof(h_C)/sizeof(h_C[0]);


  cusolverSpHandle_t cusolverH = NULL;
  csrqrInfo_t info = NULL;
  cusparseMatDescr_t descrA  = NULL;
  cudaStream_t stream = NULL;

  //prepare Arrays for the solver to be loaded

  int *d_csrRowPtrA = nullptr;
  int *d_csrColIndA = nullptr;
  double *d_csrValA = nullptr;

  double *d_b = nullptr;
  double *d_x = nullptr;

  size_t size_qr = 0;
  size_t size_internal = 0;

  void *buffer_qr = nullptr;

  const int i_m = size;
  const int nnzA = 840;

  int csrRowSize =  281;
  int csrColSize =  839;
  int *csrRow_ptr;
  int *csrCol_ptr;

  csrRow_ptr   = (int *)malloc(csrRowSize*sizeof(int));
  csrCol_ptr   = (int *)malloc(csrColSize*sizeof(int));

  creat_sp_rows_ptr(csrRow_ptr, csrRowSize);
  creat_sp_cols_ptr(csrCol_ptr, csrColSize);


  const std::vector&lt;int&gt; csrRowPtrA(csrRow_ptr, csrRow_ptr+csrRowSize);
  const std::vector&lt;int&gt; csrColPtrA(csrCol_ptr, csrCol_ptr+csrColSize);

  const std::vector&lt;float&gt; csrValA(h_C, h_C + 839);





  //std::cout &lt;&lt; top_Diag.size() + mid_Diag.size();
  cudaFree(d_col_ptr);
  cudaFree(d_row_ptr);
  cudaFree(d_elem_scan);
  cudaFree(d_C);

  free(row_ptr);
  free(col_ptr);
  free(elem_scan);
 // //thrust::copy(d_divRes.begin(), d_divRes.end(), std::ostream_iterator&lt;float&gt;(std::cout, " "));
 // thrust::for_each
 //std::cout &lt;&lt; d.size()  &lt;&lt; std::endl;
  return 0;
}

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.2 (<a href="https://orgmode.org">Org</a> mode 9.5.5)</p>
</div>
</body>
</html>
